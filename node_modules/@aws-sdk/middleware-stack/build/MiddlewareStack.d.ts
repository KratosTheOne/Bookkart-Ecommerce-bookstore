import { InitializeHandlerOptions, BuildHandlerOptions, FinalizeRequestHandlerOptions, MiddlewareType, SerializeMiddleware, FinalizeRequestMiddleware, HandlerExecutionContext, InitializeMiddleware, MiddlewareStack as IMiddlewareStack, SerializeHandlerOptions, DeserializeMiddleware, DeserializeHandlerOptions, DeserializeHandler, Pluggable, BuildMiddleware, Handler, AbsoluteLocation, RelativeLocation } from "@aws-sdk/types";
export interface MiddlewareStack<Input extends object, Output extends object> extends IMiddlewareStack<Input, Output> {
}
export declare class MiddlewareStack<Input extends object, Output extends object> {
    private readonly absoluteEntries;
    private readonly relativeEntries;
    private entriesNameMap;
    add(middleware: InitializeMiddleware<Input, Output>, options?: InitializeHandlerOptions & AbsoluteLocation): void;
    add(middleware: SerializeMiddleware<Input, Output>, options: SerializeHandlerOptions & AbsoluteLocation): void;
    add(middleware: BuildMiddleware<Input, Output>, options: BuildHandlerOptions & AbsoluteLocation): void;
    add(middleware: FinalizeRequestMiddleware<Input, Output>, options: FinalizeRequestHandlerOptions & AbsoluteLocation): void;
    add(middleware: DeserializeMiddleware<Input, Output>, options: DeserializeHandlerOptions & AbsoluteLocation): void;
    addRelativeTo(middleware: InitializeMiddleware<Input, Output>, options: InitializeHandlerOptions & RelativeLocation<Input, Output>): void;
    addRelativeTo(middleware: SerializeMiddleware<Input, Output>, options: SerializeHandlerOptions & RelativeLocation<Input, Output>): void;
    addRelativeTo(middleware: BuildMiddleware<Input, Output>, options: BuildHandlerOptions & RelativeLocation<Input, Output>): void;
    addRelativeTo(middleware: FinalizeRequestMiddleware<Input, Output>, options: FinalizeRequestHandlerOptions & RelativeLocation<Input, Output>): void;
    addRelativeTo(middleware: DeserializeMiddleware<Input, Output>, options: DeserializeHandlerOptions & RelativeLocation<Input, Output>): void;
    private sort;
    clone(): IMiddlewareStack<Input, Output>;
    concat<InputType extends Input, OutputType extends Output>(from: IMiddlewareStack<InputType, OutputType>): MiddlewareStack<InputType, OutputType>;
    remove(toRemove: MiddlewareType<Input, Output> | string): boolean;
    private removeByName;
    private removeByReference;
    removeByTag(toRemove: string): boolean;
    use(plugin: Pluggable<Input, Output>): void;
    /**
     * Resolve relative middleware entries to multiple double linked lists
     * depicting the relative location of middleware. Only middleware that have
     * direct or transitive relation will form a linked list.
     *
     * This function normalizes relative middleware into 2 categories of linked
     * lists. (1) linked list that have absolute-located middleware on one end.
     * These middleware will be resolved accordingly before or after the absolute-
     * located middleware. (2) Linked list that have no absolute-located middleware
     * on any end. They will be resolved to corresponding step with normal priority
     *
     * The 2 types of linked list will return as a tuple
     */
    private normalizeRelativeEntries;
    /**
     * Get a final list of middleware in the order of being executed in the resolved handler.
     * If relative entries list is not empty, those entries will be added to final middleware
     * list with rules below:
     * 1. if `toMiddleware` exists in the specific `step`, the middleware will be inserted before
     *     or after the specified `toMiddleware`
     * 2. if `toMiddleware` doesn't exist in the specific `step`, the middleware will be appended
     *     to specific `step` with priority of `normal`
     */
    private getMiddlewareList;
    resolve<InputType extends Input, OutputType extends Output>(handler: DeserializeHandler<InputType, OutputType>, context: HandlerExecutionContext): Handler<InputType, OutputType>;
}
