"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var RemoteProviderInit_1 = require("./remoteProvider/RemoteProviderInit");
var httpGet_1 = require("./remoteProvider/httpGet");
var ImdsCredentials_1 = require("./remoteProvider/ImdsCredentials");
var retry_1 = require("./remoteProvider/retry");
var property_provider_1 = require("@aws-sdk/property-provider");
var url_1 = require("url");
exports.ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
exports.ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
exports.ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
/**
 * Creates a credential provider that will source credentials from the ECS
 * Container Metadata Service
 */
function fromContainerMetadata(init) {
    var _this = this;
    if (init === void 0) { init = {}; }
    var _a = RemoteProviderInit_1.providerConfigFromInit(init), timeout = _a.timeout, maxRetries = _a.maxRetries;
    return function () {
        return getCmdsUri().then(function (url) {
            return retry_1.retry(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var credsResponse, _a, _b;
                return tslib_1.__generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            _b = (_a = JSON).parse;
                            return [4 /*yield*/, requestFromEcsImds(timeout, url)];
                        case 1:
                            credsResponse = _b.apply(_a, [_c.sent()]);
                            if (!ImdsCredentials_1.isImdsCredentials(credsResponse)) {
                                throw new property_provider_1.ProviderError("Invalid response received from instance metadata service.");
                            }
                            return [2 /*return*/, ImdsCredentials_1.fromImdsCredentials(credsResponse)];
                    }
                });
            }); }, maxRetries);
        });
    };
}
exports.fromContainerMetadata = fromContainerMetadata;
function requestFromEcsImds(timeout, options) {
    if (process.env[exports.ENV_CMDS_AUTH_TOKEN]) {
        var _a = options.headers, headers = _a === void 0 ? {} : _a;
        headers.Authorization = process.env[exports.ENV_CMDS_AUTH_TOKEN];
        options.headers = headers;
    }
    return httpGet_1.httpGet(tslib_1.__assign(tslib_1.__assign({}, options), { timeout: timeout })).then(function (buffer) { return buffer.toString(); });
}
var CMDS_IP = "169.254.170.2";
var GREENGRASS_HOSTS = {
    localhost: true,
    "127.0.0.1": true
};
var GREENGRASS_PROTOCOLS = {
    "http:": true,
    "https:": true
};
function getCmdsUri() {
    if (process.env[exports.ENV_CMDS_RELATIVE_URI]) {
        return Promise.resolve({
            hostname: CMDS_IP,
            path: process.env[exports.ENV_CMDS_RELATIVE_URI]
        });
    }
    if (process.env[exports.ENV_CMDS_FULL_URI]) {
        var parsed = url_1.parse(process.env[exports.ENV_CMDS_FULL_URI]);
        if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
            return Promise.reject(new property_provider_1.ProviderError(parsed.hostname + " is not a valid container metadata service hostname", false));
        }
        if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
            return Promise.reject(new property_provider_1.ProviderError(parsed.protocol + " is not a valid container metadata service protocol", false));
        }
        return Promise.resolve(tslib_1.__assign(tslib_1.__assign({}, parsed), { port: parsed.port ? parseInt(parsed.port, 10) : undefined }));
    }
    return Promise.reject(new property_provider_1.ProviderError("The container metadata credential provider cannot be used unless" +
        (" the " + exports.ENV_CMDS_RELATIVE_URI + " or " + exports.ENV_CMDS_FULL_URI + " environment") +
        " variable is set", false));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJvbUNvbnRhaW5lck1ldGFkYXRhLmpzIiwic291cmNlUm9vdCI6Ii4vc3JjLyIsInNvdXJjZXMiOlsiZnJvbUNvbnRhaW5lck1ldGFkYXRhLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLDBFQUc2QztBQUM3QyxvREFBbUQ7QUFDbkQsb0VBRzBDO0FBQzFDLGdEQUErQztBQUMvQyxnRUFBMkQ7QUFDM0QsMkJBQTRCO0FBR2YsUUFBQSxpQkFBaUIsR0FBRyxvQ0FBb0MsQ0FBQztBQUN6RCxRQUFBLHFCQUFxQixHQUFHLHdDQUF3QyxDQUFDO0FBQ2pFLFFBQUEsbUJBQW1CLEdBQUcsbUNBQW1DLENBQUM7QUFFdkU7OztHQUdHO0FBQ0gsU0FBZ0IscUJBQXFCLENBQ25DLElBQTZCO0lBRC9CLGlCQW9CQztJQW5CQyxxQkFBQSxFQUFBLFNBQTZCO0lBRXZCLElBQUEsc0RBQXNELEVBQXBELG9CQUFPLEVBQUUsMEJBQTJDLENBQUM7SUFDN0QsT0FBTztRQUNMLE9BQU8sVUFBVSxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQUEsR0FBRztZQUMxQixPQUFBLGFBQUssQ0FBQzs7Ozs7NEJBQ2tCLEtBQUEsQ0FBQSxLQUFBLElBQUksQ0FBQSxDQUFDLEtBQUssQ0FBQTs0QkFDOUIscUJBQU0sa0JBQWtCLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxFQUFBOzs0QkFEbEMsYUFBYSxHQUFHLGNBQ3BCLFNBQXNDLEVBQ3ZDOzRCQUNELElBQUksQ0FBQyxtQ0FBaUIsQ0FBQyxhQUFhLENBQUMsRUFBRTtnQ0FDckMsTUFBTSxJQUFJLGlDQUFhLENBQ3JCLDJEQUEyRCxDQUM1RCxDQUFDOzZCQUNIOzRCQUVELHNCQUFPLHFDQUFtQixDQUFDLGFBQWEsQ0FBQyxFQUFDOzs7aUJBQzNDLEVBQUUsVUFBVSxDQUFDO1FBWGQsQ0FXYyxDQUNmLENBQUM7SUFDSixDQUFDLENBQUM7QUFDSixDQUFDO0FBcEJELHNEQW9CQztBQUVELFNBQVMsa0JBQWtCLENBQ3pCLE9BQWUsRUFDZixPQUF1QjtJQUV2QixJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsMkJBQW1CLENBQUMsRUFBRTtRQUM1QixJQUFBLG9CQUFZLEVBQVosaUNBQVksQ0FBYTtRQUNqQyxPQUFPLENBQUMsYUFBYSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsMkJBQW1CLENBQUMsQ0FBQztRQUN6RCxPQUFPLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztLQUMzQjtJQUVELE9BQU8saUJBQU8sdUNBQ1QsT0FBTyxLQUNWLE9BQU8sU0FBQSxJQUNQLENBQUMsSUFBSSxDQUFDLFVBQUEsTUFBTSxJQUFJLE9BQUEsTUFBTSxDQUFDLFFBQVEsRUFBRSxFQUFqQixDQUFpQixDQUFDLENBQUM7QUFDdkMsQ0FBQztBQUVELElBQU0sT0FBTyxHQUFHLGVBQWUsQ0FBQztBQUNoQyxJQUFNLGdCQUFnQixHQUFHO0lBQ3ZCLFNBQVMsRUFBRSxJQUFJO0lBQ2YsV0FBVyxFQUFFLElBQUk7Q0FDbEIsQ0FBQztBQUNGLElBQU0sb0JBQW9CLEdBQUc7SUFDM0IsT0FBTyxFQUFFLElBQUk7SUFDYixRQUFRLEVBQUUsSUFBSTtDQUNmLENBQUM7QUFFRixTQUFTLFVBQVU7SUFDakIsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLDZCQUFxQixDQUFDLEVBQUU7UUFDdEMsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDO1lBQ3JCLFFBQVEsRUFBRSxPQUFPO1lBQ2pCLElBQUksRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLDZCQUFxQixDQUFDO1NBQ3pDLENBQUMsQ0FBQztLQUNKO0lBRUQsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLHlCQUFpQixDQUFDLEVBQUU7UUFDbEMsSUFBTSxNQUFNLEdBQUcsV0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMseUJBQWlCLENBQUUsQ0FBQyxDQUFDO1FBQ3RELElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxJQUFJLGdCQUFnQixDQUFDLEVBQUU7WUFDOUQsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUNuQixJQUFJLGlDQUFhLENBQ1osTUFBTSxDQUFDLFFBQVEsd0RBQXFELEVBQ3ZFLEtBQUssQ0FDTixDQUNGLENBQUM7U0FDSDtRQUVELElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxJQUFJLG9CQUFvQixDQUFDLEVBQUU7WUFDbEUsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUNuQixJQUFJLGlDQUFhLENBQ1osTUFBTSxDQUFDLFFBQVEsd0RBQXFELEVBQ3ZFLEtBQUssQ0FDTixDQUNGLENBQUM7U0FDSDtRQUVELE9BQU8sT0FBTyxDQUFDLE9BQU8sdUNBQ2pCLE1BQU0sS0FDVCxJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsSUFDekQsQ0FBQztLQUNKO0lBRUQsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUNuQixJQUFJLGlDQUFhLENBQ2Ysa0VBQWtFO1NBQ2hFLFVBQVEsNkJBQXFCLFlBQU8seUJBQWlCLGlCQUFjLENBQUE7UUFDbkUsa0JBQWtCLEVBQ3BCLEtBQUssQ0FDTixDQUNGLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ3JlZGVudGlhbFByb3ZpZGVyIH0gZnJvbSBcIkBhd3Mtc2RrL3R5cGVzXCI7XG5pbXBvcnQge1xuICBSZW1vdGVQcm92aWRlckluaXQsXG4gIHByb3ZpZGVyQ29uZmlnRnJvbUluaXRcbn0gZnJvbSBcIi4vcmVtb3RlUHJvdmlkZXIvUmVtb3RlUHJvdmlkZXJJbml0XCI7XG5pbXBvcnQgeyBodHRwR2V0IH0gZnJvbSBcIi4vcmVtb3RlUHJvdmlkZXIvaHR0cEdldFwiO1xuaW1wb3J0IHtcbiAgZnJvbUltZHNDcmVkZW50aWFscyxcbiAgaXNJbWRzQ3JlZGVudGlhbHNcbn0gZnJvbSBcIi4vcmVtb3RlUHJvdmlkZXIvSW1kc0NyZWRlbnRpYWxzXCI7XG5pbXBvcnQgeyByZXRyeSB9IGZyb20gXCIuL3JlbW90ZVByb3ZpZGVyL3JldHJ5XCI7XG5pbXBvcnQgeyBQcm92aWRlckVycm9yIH0gZnJvbSBcIkBhd3Mtc2RrL3Byb3BlcnR5LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gXCJ1cmxcIjtcbmltcG9ydCB7IFJlcXVlc3RPcHRpb25zIH0gZnJvbSBcImh0dHBcIjtcblxuZXhwb3J0IGNvbnN0IEVOVl9DTURTX0ZVTExfVVJJID0gXCJBV1NfQ09OVEFJTkVSX0NSRURFTlRJQUxTX0ZVTExfVVJJXCI7XG5leHBvcnQgY29uc3QgRU5WX0NNRFNfUkVMQVRJVkVfVVJJID0gXCJBV1NfQ09OVEFJTkVSX0NSRURFTlRJQUxTX1JFTEFUSVZFX1VSSVwiO1xuZXhwb3J0IGNvbnN0IEVOVl9DTURTX0FVVEhfVE9LRU4gPSBcIkFXU19DT05UQUlORVJfQVVUSE9SSVpBVElPTl9UT0tFTlwiO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjcmVkZW50aWFsIHByb3ZpZGVyIHRoYXQgd2lsbCBzb3VyY2UgY3JlZGVudGlhbHMgZnJvbSB0aGUgRUNTXG4gKiBDb250YWluZXIgTWV0YWRhdGEgU2VydmljZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUNvbnRhaW5lck1ldGFkYXRhKFxuICBpbml0OiBSZW1vdGVQcm92aWRlckluaXQgPSB7fVxuKTogQ3JlZGVudGlhbFByb3ZpZGVyIHtcbiAgY29uc3QgeyB0aW1lb3V0LCBtYXhSZXRyaWVzIH0gPSBwcm92aWRlckNvbmZpZ0Zyb21Jbml0KGluaXQpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHJldHVybiBnZXRDbWRzVXJpKCkudGhlbih1cmwgPT5cbiAgICAgIHJldHJ5KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY3JlZHNSZXNwb25zZSA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgYXdhaXQgcmVxdWVzdEZyb21FY3NJbWRzKHRpbWVvdXQsIHVybClcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFpc0ltZHNDcmVkZW50aWFscyhjcmVkc1Jlc3BvbnNlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBQcm92aWRlckVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gaW5zdGFuY2UgbWV0YWRhdGEgc2VydmljZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnJvbUltZHNDcmVkZW50aWFscyhjcmVkc1Jlc3BvbnNlKTtcbiAgICAgIH0sIG1heFJldHJpZXMpXG4gICAgKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVxdWVzdEZyb21FY3NJbWRzKFxuICB0aW1lb3V0OiBudW1iZXIsXG4gIG9wdGlvbnM6IFJlcXVlc3RPcHRpb25zXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBpZiAocHJvY2Vzcy5lbnZbRU5WX0NNRFNfQVVUSF9UT0tFTl0pIHtcbiAgICBjb25zdCB7IGhlYWRlcnMgPSB7fSB9ID0gb3B0aW9ucztcbiAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBwcm9jZXNzLmVudltFTlZfQ01EU19BVVRIX1RPS0VOXTtcbiAgICBvcHRpb25zLmhlYWRlcnMgPSBoZWFkZXJzO1xuICB9XG5cbiAgcmV0dXJuIGh0dHBHZXQoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGltZW91dFxuICB9KS50aGVuKGJ1ZmZlciA9PiBidWZmZXIudG9TdHJpbmcoKSk7XG59XG5cbmNvbnN0IENNRFNfSVAgPSBcIjE2OS4yNTQuMTcwLjJcIjtcbmNvbnN0IEdSRUVOR1JBU1NfSE9TVFMgPSB7XG4gIGxvY2FsaG9zdDogdHJ1ZSxcbiAgXCIxMjcuMC4wLjFcIjogdHJ1ZVxufTtcbmNvbnN0IEdSRUVOR1JBU1NfUFJPVE9DT0xTID0ge1xuICBcImh0dHA6XCI6IHRydWUsXG4gIFwiaHR0cHM6XCI6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGdldENtZHNVcmkoKTogUHJvbWlzZTxSZXF1ZXN0T3B0aW9ucz4ge1xuICBpZiAocHJvY2Vzcy5lbnZbRU5WX0NNRFNfUkVMQVRJVkVfVVJJXSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgaG9zdG5hbWU6IENNRFNfSVAsXG4gICAgICBwYXRoOiBwcm9jZXNzLmVudltFTlZfQ01EU19SRUxBVElWRV9VUkldXG4gICAgfSk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnZbRU5WX0NNRFNfRlVMTF9VUkldKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2UocHJvY2Vzcy5lbnZbRU5WX0NNRFNfRlVMTF9VUkldISk7XG4gICAgaWYgKCFwYXJzZWQuaG9zdG5hbWUgfHwgIShwYXJzZWQuaG9zdG5hbWUgaW4gR1JFRU5HUkFTU19IT1NUUykpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IFByb3ZpZGVyRXJyb3IoXG4gICAgICAgICAgYCR7cGFyc2VkLmhvc3RuYW1lfSBpcyBub3QgYSB2YWxpZCBjb250YWluZXIgbWV0YWRhdGEgc2VydmljZSBob3N0bmFtZWAsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcnNlZC5wcm90b2NvbCB8fCAhKHBhcnNlZC5wcm90b2NvbCBpbiBHUkVFTkdSQVNTX1BST1RPQ09MUykpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IFByb3ZpZGVyRXJyb3IoXG4gICAgICAgICAgYCR7cGFyc2VkLnByb3RvY29sfSBpcyBub3QgYSB2YWxpZCBjb250YWluZXIgbWV0YWRhdGEgc2VydmljZSBwcm90b2NvbGAsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIC4uLnBhcnNlZCxcbiAgICAgIHBvcnQ6IHBhcnNlZC5wb3J0ID8gcGFyc2VJbnQocGFyc2VkLnBvcnQsIDEwKSA6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgIG5ldyBQcm92aWRlckVycm9yKFxuICAgICAgXCJUaGUgY29udGFpbmVyIG1ldGFkYXRhIGNyZWRlbnRpYWwgcHJvdmlkZXIgY2Fubm90IGJlIHVzZWQgdW5sZXNzXCIgK1xuICAgICAgICBgIHRoZSAke0VOVl9DTURTX1JFTEFUSVZFX1VSSX0gb3IgJHtFTlZfQ01EU19GVUxMX1VSSX0gZW52aXJvbm1lbnRgICtcbiAgICAgICAgXCIgdmFyaWFibGUgaXMgc2V0XCIsXG4gICAgICBmYWxzZVxuICAgIClcbiAgKTtcbn1cbiJdfQ==