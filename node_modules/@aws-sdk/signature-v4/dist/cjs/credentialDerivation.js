"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("./constants");
const signingKeyCache = {};
const cacheQueue = [];
/**
 * Create a string describing the scope of credentials used to sign a request.
 *
 * @param shortDate The current calendar date in the form YYYYMMDD.
 * @param region    The AWS region in which the service resides.
 * @param service   The service to which the signed request is being sent.
 */
function createScope(shortDate, region, service) {
    return `${shortDate}/${region}/${service}/${constants_1.KEY_TYPE_IDENTIFIER}`;
}
exports.createScope = createScope;
/**
 * Derive a signing key from its composite parts
 *
 * @param sha256Constructor A constructor function that can instantiate SHA-256
 *                          hash objects.
 * @param credentials       The credentials with which the request will be
 *                          signed.
 * @param shortDate         The current calendar date in the form YYYYMMDD.
 * @param region            The AWS region in which the service resides.
 * @param service           The service to which the signed request is being
 *                          sent.
 */
function getSigningKey(sha256Constructor, credentials, shortDate, region, service) {
    const cacheKey = `${shortDate}:${region}:${service}:` +
        `${credentials.accessKeyId}:${credentials.sessionToken}`;
    if (cacheKey in signingKeyCache) {
        return signingKeyCache[cacheKey];
    }
    cacheQueue.push(cacheKey);
    while (cacheQueue.length > constants_1.MAX_CACHE_SIZE) {
        delete signingKeyCache[cacheQueue.shift()];
    }
    return (signingKeyCache[cacheKey] = new Promise((resolve, reject) => {
        let keyPromise = Promise.resolve(`AWS4${credentials.secretAccessKey}`);
        for (let signable of [shortDate, region, service, constants_1.KEY_TYPE_IDENTIFIER]) {
            keyPromise = keyPromise.then(intermediateKey => hmac(sha256Constructor, intermediateKey, signable));
            keyPromise.catch(() => { });
        }
        keyPromise.then(resolve, reason => {
            delete signingKeyCache[cacheKey];
            reject(reason);
        });
    }));
}
exports.getSigningKey = getSigningKey;
/**
 * @internal
 */
function clearCredentialCache() {
    cacheQueue.length = 0;
    Object.keys(signingKeyCache).forEach(cacheKey => {
        delete signingKeyCache[cacheKey];
    });
}
exports.clearCredentialCache = clearCredentialCache;
function hmac(ctor, secret, data) {
    const hash = new ctor(secret);
    hash.update(data);
    return hash.digest();
}
//# sourceMappingURL=credentialDerivation.js.map