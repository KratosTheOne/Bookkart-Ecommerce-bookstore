import { ALWAYS_UNSIGNABLE_HEADERS, PROXY_HEADER_PATTERN, SEC_HEADER_PATTERN } from "./constants";
/**
 * @internal
 */
export function getCanonicalHeaders(_a, unsignableHeaders, signableHeaders) {
    var headers = _a.headers;
    var canonical = {};
    for (var _i = 0, _b = Object.keys(headers).sort(); _i < _b.length; _i++) {
        var headerName = _b[_i];
        var canonicalHeaderName = headerName.toLowerCase();
        if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || (unsignableHeaders === null || unsignableHeaders === void 0 ? void 0 : unsignableHeaders.has(canonicalHeaderName)) ||
            PROXY_HEADER_PATTERN.test(canonicalHeaderName) ||
            SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
            if (!signableHeaders ||
                (signableHeaders && !signableHeaders.has(canonicalHeaderName))) {
                continue;
            }
        }
        canonical[canonicalHeaderName] = headers[headerName]
            .trim()
            .replace(/\s+/g, " ");
    }
    return canonical;
}
//# sourceMappingURL=getCanonicalHeaders.js.map