"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const buffer_1 = require("buffer");
function getSignatureBinary(signature) {
    const buf = buffer_1.Buffer.from(signature, "hex");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
}
exports.getSignatureBinary = getSignatureBinary;
/**
 * Convert object stream piped in into an async iterable. This
 * daptor should be deprecated when Node stream iterator is stable.
 * Caveat: this adaptor won't have backpressure to inwards stream
 *
 * Reference: https://nodejs.org/docs/latest-v11.x/api/stream.html#stream_readable_symbol_asynciterator
 */
function readabletoIterable(readStream) {
    return tslib_1.__asyncGenerator(this, arguments, function* readabletoIterable_1() {
        let streamEnded = false;
        let generationEnded = false;
        const records = new Array();
        readStream.on("error", err => {
            if (!streamEnded) {
                streamEnded = true;
            }
            if (err) {
                throw err;
            }
        });
        readStream.on("data", data => {
            records.push(data);
        });
        readStream.on("end", () => {
            streamEnded = true;
        });
        while (!generationEnded) {
            const value = yield tslib_1.__await(new Promise(resolve => setTimeout(() => resolve(records.shift()), 0)));
            if (value) {
                yield yield tslib_1.__await(value);
            }
            generationEnded = streamEnded && records.length === 0;
        }
    });
}
exports.readabletoIterable = readabletoIterable;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsbUNBQWdDO0FBR2hDLFNBQWdCLGtCQUFrQixDQUFDLFNBQWlCO0lBQ2xELE1BQU0sR0FBRyxHQUFHLGVBQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzFDLE9BQU8sSUFBSSxVQUFVLENBQ25CLEdBQUcsQ0FBQyxNQUFNLEVBQ1YsR0FBRyxDQUFDLFVBQVUsRUFDZCxHQUFHLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQyxpQkFBaUIsQ0FDOUMsQ0FBQztBQUNKLENBQUM7QUFQRCxnREFPQztBQUVEOzs7Ozs7R0FNRztBQUVILFNBQXVCLGtCQUFrQixDQUN2QyxVQUFvQjs7UUFFcEIsSUFBSSxXQUFXLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLElBQUksZUFBZSxHQUFHLEtBQUssQ0FBQztRQUM1QixNQUFNLE9BQU8sR0FBRyxJQUFJLEtBQUssRUFBSyxDQUFDO1FBRS9CLFVBQVUsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxFQUFFO1lBQzNCLElBQUksQ0FBQyxXQUFXLEVBQUU7Z0JBQ2hCLFdBQVcsR0FBRyxJQUFJLENBQUM7YUFDcEI7WUFDRCxJQUFJLEdBQUcsRUFBRTtnQkFDUCxNQUFNLEdBQUcsQ0FBQzthQUNYO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFSCxVQUFVLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsRUFBRTtZQUMzQixPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JCLENBQUMsQ0FBQyxDQUFDO1FBRUgsVUFBVSxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFO1lBQ3hCLFdBQVcsR0FBRyxJQUFJLENBQUM7UUFDckIsQ0FBQyxDQUFDLENBQUM7UUFFSCxPQUFPLENBQUMsZUFBZSxFQUFFO1lBQ3ZCLE1BQU0sS0FBSyxHQUFHLHNCQUFNLElBQUksT0FBTyxDQUFJLE9BQU8sQ0FBQyxFQUFFLENBQzNDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQzlDLENBQUEsQ0FBQztZQUNGLElBQUksS0FBSyxFQUFFO2dCQUNULDRCQUFNLEtBQUssQ0FBQSxDQUFDO2FBQ2I7WUFDRCxlQUFlLEdBQUcsV0FBVyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO1NBQ3ZEO0lBQ0gsQ0FBQztDQUFBO0FBakNELGdEQWlDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gXCJidWZmZXJcIjtcbmltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSBcInN0cmVhbVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnbmF0dXJlQmluYXJ5KHNpZ25hdHVyZTogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSwgXCJoZXhcIik7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShcbiAgICBidWYuYnVmZmVyLFxuICAgIGJ1Zi5ieXRlT2Zmc2V0LFxuICAgIGJ1Zi5ieXRlTGVuZ3RoIC8gVWludDhBcnJheS5CWVRFU19QRVJfRUxFTUVOVFxuICApO1xufVxuXG4vKipcbiAqIENvbnZlcnQgb2JqZWN0IHN0cmVhbSBwaXBlZCBpbiBpbnRvIGFuIGFzeW5jIGl0ZXJhYmxlLiBUaGlzXG4gKiBkYXB0b3Igc2hvdWxkIGJlIGRlcHJlY2F0ZWQgd2hlbiBOb2RlIHN0cmVhbSBpdGVyYXRvciBpcyBzdGFibGUuXG4gKiBDYXZlYXQ6IHRoaXMgYWRhcHRvciB3b24ndCBoYXZlIGJhY2twcmVzc3VyZSB0byBpbndhcmRzIHN0cmVhbVxuICpcbiAqIFJlZmVyZW5jZTogaHR0cHM6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0LXYxMS54L2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fcmVhZGFibGVfc3ltYm9sX2FzeW5jaXRlcmF0b3JcbiAqL1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIHJlYWRhYmxldG9JdGVyYWJsZTxUPihcbiAgcmVhZFN0cmVhbTogUmVhZGFibGVcbik6IEFzeW5jSXRlcmFibGU8VD4ge1xuICBsZXQgc3RyZWFtRW5kZWQgPSBmYWxzZTtcbiAgbGV0IGdlbmVyYXRpb25FbmRlZCA9IGZhbHNlO1xuICBjb25zdCByZWNvcmRzID0gbmV3IEFycmF5PFQ+KCk7XG5cbiAgcmVhZFN0cmVhbS5vbihcImVycm9yXCIsIGVyciA9PiB7XG4gICAgaWYgKCFzdHJlYW1FbmRlZCkge1xuICAgICAgc3RyZWFtRW5kZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9KTtcblxuICByZWFkU3RyZWFtLm9uKFwiZGF0YVwiLCBkYXRhID0+IHtcbiAgICByZWNvcmRzLnB1c2goZGF0YSk7XG4gIH0pO1xuXG4gIHJlYWRTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgIHN0cmVhbUVuZGVkID0gdHJ1ZTtcbiAgfSk7XG5cbiAgd2hpbGUgKCFnZW5lcmF0aW9uRW5kZWQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IG5ldyBQcm9taXNlPFQ+KHJlc29sdmUgPT5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZShyZWNvcmRzLnNoaWZ0KCkpLCAwKVxuICAgICk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9XG4gICAgZ2VuZXJhdGlvbkVuZGVkID0gc3RyZWFtRW5kZWQgJiYgcmVjb3Jkcy5sZW5ndGggPT09IDA7XG4gIH1cbn1cbiJdfQ==