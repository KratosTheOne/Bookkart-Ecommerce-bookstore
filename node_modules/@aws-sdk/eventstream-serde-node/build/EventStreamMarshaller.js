"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const eventstream_marshaller_1 = require("@aws-sdk/eventstream-marshaller");
const stream_1 = require("stream");
const utils_1 = require("./utils");
const EventMessageChunkerStream_1 = require("./EventMessageChunkerStream");
const MessageUnmarshallerStream_1 = require("./MessageUnmarshallerStream");
const EventDeserializerStream_1 = require("./EventDeserializerStream");
class EventStreamMarshaller {
    constructor({ utf8Encoder, utf8Decoder }) {
        this.eventMarshaller = new eventstream_marshaller_1.EventStreamMarshaller(utf8Encoder, utf8Decoder);
    }
    deserialize(body, deserializer) {
        const eventDeserializerStream = new EventDeserializerStream_1.EventDeserializerStream({
            deserializer
        });
        stream_1.pipeline(body, new EventMessageChunkerStream_1.EventMessageChunkerStream(), //frame the body
        new MessageUnmarshallerStream_1.MessageUnmarshallerStream({
            eventMarshaller: this.eventMarshaller
        }), eventDeserializerStream, err => {
            if (err)
                throw err;
        });
        //should use stream[Symbol.asyncIterable] when the api is stable
        //reference: https://nodejs.org/docs/latest-v11.x/api/stream.html#stream_readable_symbol_asynciterator
        if (typeof eventDeserializerStream[Symbol.asyncIterator] === "function") {
            // use the experimental feature if available.
            return eventDeserializerStream;
        }
        return utils_1.readabletoIterable(eventDeserializerStream);
    }
    serialize(input, serializer) {
        //will use Readable.from(Iterable) in Node12
        const inputIterator = input[Symbol.asyncIterator]();
        const self = this;
        let generatorDone = false;
        const stream = new stream_1.Readable({
            objectMode: true,
            async read() {
                try {
                    const result = await inputIterator.next();
                    if (result.done && generatorDone) {
                        this.push(null);
                        return;
                    }
                    const payloadBuf = result.done
                        ? new Uint8Array(0)
                        : self.eventMarshaller.marshall(serializer(result.value));
                    this.push(payloadBuf);
                    if (result.done && !generatorDone)
                        generatorDone = true;
                }
                catch (e) {
                    this.destroy(e);
                }
            }
        });
        //TODO: use 'autoDestroy' when targeting Node 11
        //reference: https://nodejs.org/dist/latest-v13.x/docs/api/stream.html#stream_new_stream_readable_options
        stream.on("error", () => {
            stream.destroy();
        });
        stream.on("end", () => {
            stream.destroy();
        });
        return stream;
    }
}
exports.EventStreamMarshaller = EventStreamMarshaller;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXZlbnRTdHJlYW1NYXJzaGFsbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL0V2ZW50U3RyZWFtTWFyc2hhbGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDRFQUEyRjtBQU8zRixtQ0FBNEM7QUFDNUMsbUNBQTZDO0FBQzdDLDJFQUF3RTtBQUN4RSwyRUFBd0U7QUFDeEUsdUVBQW9FO0FBU3BFLE1BQWEscUJBQXFCO0lBRWhDLFlBQVksRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFnQztRQUNwRSxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksOENBQWUsQ0FBQyxXQUFXLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDdkUsQ0FBQztJQUVELFdBQVcsQ0FDVCxJQUFjLEVBQ2QsWUFBd0Q7UUFFeEQsTUFBTSx1QkFBdUIsR0FBRyxJQUFJLGlEQUF1QixDQUFDO1lBQzFELFlBQVk7U0FDYixDQUFDLENBQUM7UUFDSCxpQkFBUSxDQUNOLElBQUksRUFDSixJQUFJLHFEQUF5QixFQUFFLEVBQUUsZ0JBQWdCO1FBQ2pELElBQUkscURBQXlCLENBQUM7WUFDNUIsZUFBZSxFQUFFLElBQUksQ0FBQyxlQUFlO1NBQ3RDLENBQUMsRUFDRix1QkFBdUIsRUFDdkIsR0FBRyxDQUFDLEVBQUU7WUFDSixJQUFJLEdBQUc7Z0JBQUUsTUFBTSxHQUFHLENBQUM7UUFDckIsQ0FBQyxDQUNGLENBQUM7UUFDRixnRUFBZ0U7UUFDaEUsc0dBQXNHO1FBQ3RHLElBQUksT0FBTyx1QkFBdUIsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEtBQUssVUFBVSxFQUFFO1lBQ3ZFLDZDQUE2QztZQUM3QyxPQUFPLHVCQUF1QixDQUFDO1NBQ2hDO1FBQ0QsT0FBTywwQkFBa0IsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFRCxTQUFTLENBQ1AsS0FBdUIsRUFDdkIsVUFBaUM7UUFFakMsNENBQTRDO1FBQzVDLE1BQU0sYUFBYSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQztRQUNwRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDO1FBQzFCLE1BQU0sTUFBTSxHQUFHLElBQUksaUJBQVEsQ0FBQztZQUMxQixVQUFVLEVBQUUsSUFBSTtZQUNoQixLQUFLLENBQUMsSUFBSTtnQkFDUixJQUFJO29CQUNGLE1BQU0sTUFBTSxHQUFHLE1BQU0sYUFBYSxDQUFDLElBQUksRUFBRSxDQUFDO29CQUMxQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLElBQUksYUFBYSxFQUFFO3dCQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO3dCQUNoQixPQUFPO3FCQUNSO29CQUNELE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxJQUFJO3dCQUM1QixDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDO3dCQUNuQixDQUFDLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO29CQUM1RCxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO29CQUN0QixJQUFJLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxhQUFhO3dCQUFFLGFBQWEsR0FBRyxJQUFJLENBQUM7aUJBQ3pEO2dCQUFDLE9BQU8sQ0FBQyxFQUFFO29CQUNWLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ2pCO1lBQ0gsQ0FBQztTQUNGLENBQUMsQ0FBQztRQUNILGdEQUFnRDtRQUNoRCx5R0FBeUc7UUFDekcsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFO1lBQ3RCLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNuQixDQUFDLENBQUMsQ0FBQztRQUNILE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRTtZQUNwQixNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDbkIsQ0FBQyxDQUFDLENBQUM7UUFDSCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0NBQ0Y7QUF0RUQsc0RBc0VDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRTdHJlYW1NYXJzaGFsbGVyIGFzIEV2ZW50TWFyc2hhbGxlciB9IGZyb20gXCJAYXdzLXNkay9ldmVudHN0cmVhbS1tYXJzaGFsbGVyXCI7XG5pbXBvcnQge1xuICBFbmNvZGVyLFxuICBEZWNvZGVyLFxuICBNZXNzYWdlLFxuICBFdmVudFN0cmVhbU1hcnNoYWxsZXIgYXMgSUV2ZW50U3RyZWFtTWFyc2hhbGxlclxufSBmcm9tIFwiQGF3cy1zZGsvdHlwZXNcIjtcbmltcG9ydCB7IFJlYWRhYmxlLCBwaXBlbGluZSB9IGZyb20gXCJzdHJlYW1cIjtcbmltcG9ydCB7IHJlYWRhYmxldG9JdGVyYWJsZSB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBFdmVudE1lc3NhZ2VDaHVua2VyU3RyZWFtIH0gZnJvbSBcIi4vRXZlbnRNZXNzYWdlQ2h1bmtlclN0cmVhbVwiO1xuaW1wb3J0IHsgTWVzc2FnZVVubWFyc2hhbGxlclN0cmVhbSB9IGZyb20gXCIuL01lc3NhZ2VVbm1hcnNoYWxsZXJTdHJlYW1cIjtcbmltcG9ydCB7IEV2ZW50RGVzZXJpYWxpemVyU3RyZWFtIH0gZnJvbSBcIi4vRXZlbnREZXNlcmlhbGl6ZXJTdHJlYW1cIjtcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudFN0cmVhbU1hcnNoYWxsZXIgZXh0ZW5kcyBJRXZlbnRTdHJlYW1NYXJzaGFsbGVyIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRTdHJlYW1NYXJzaGFsbGVyT3B0aW9ucyB7XG4gIHV0ZjhFbmNvZGVyOiBFbmNvZGVyO1xuICB1dGY4RGVjb2RlcjogRGVjb2Rlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEV2ZW50U3RyZWFtTWFyc2hhbGxlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZXZlbnRNYXJzaGFsbGVyOiBFdmVudE1hcnNoYWxsZXI7XG4gIGNvbnN0cnVjdG9yKHsgdXRmOEVuY29kZXIsIHV0ZjhEZWNvZGVyIH06IEV2ZW50U3RyZWFtTWFyc2hhbGxlck9wdGlvbnMpIHtcbiAgICB0aGlzLmV2ZW50TWFyc2hhbGxlciA9IG5ldyBFdmVudE1hcnNoYWxsZXIodXRmOEVuY29kZXIsIHV0ZjhEZWNvZGVyKTtcbiAgfVxuXG4gIGRlc2VyaWFsaXplPFQ+KFxuICAgIGJvZHk6IFJlYWRhYmxlLFxuICAgIGRlc2VyaWFsaXplcjogKGlucHV0OiB7IFtldmVudDogc3RyaW5nXTogTWVzc2FnZSB9KSA9PiBUXG4gICk6IEFzeW5jSXRlcmFibGU8VD4ge1xuICAgIGNvbnN0IGV2ZW50RGVzZXJpYWxpemVyU3RyZWFtID0gbmV3IEV2ZW50RGVzZXJpYWxpemVyU3RyZWFtKHtcbiAgICAgIGRlc2VyaWFsaXplclxuICAgIH0pO1xuICAgIHBpcGVsaW5lKFxuICAgICAgYm9keSxcbiAgICAgIG5ldyBFdmVudE1lc3NhZ2VDaHVua2VyU3RyZWFtKCksIC8vZnJhbWUgdGhlIGJvZHlcbiAgICAgIG5ldyBNZXNzYWdlVW5tYXJzaGFsbGVyU3RyZWFtKHtcbiAgICAgICAgZXZlbnRNYXJzaGFsbGVyOiB0aGlzLmV2ZW50TWFyc2hhbGxlclxuICAgICAgfSksXG4gICAgICBldmVudERlc2VyaWFsaXplclN0cmVhbSxcbiAgICAgIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHRocm93IGVycjtcbiAgICAgIH1cbiAgICApO1xuICAgIC8vc2hvdWxkIHVzZSBzdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmFibGVdIHdoZW4gdGhlIGFwaSBpcyBzdGFibGVcbiAgICAvL3JlZmVyZW5jZTogaHR0cHM6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0LXYxMS54L2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fcmVhZGFibGVfc3ltYm9sX2FzeW5jaXRlcmF0b3JcbiAgICBpZiAodHlwZW9mIGV2ZW50RGVzZXJpYWxpemVyU3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAvLyB1c2UgdGhlIGV4cGVyaW1lbnRhbCBmZWF0dXJlIGlmIGF2YWlsYWJsZS5cbiAgICAgIHJldHVybiBldmVudERlc2VyaWFsaXplclN0cmVhbTtcbiAgICB9XG4gICAgcmV0dXJuIHJlYWRhYmxldG9JdGVyYWJsZShldmVudERlc2VyaWFsaXplclN0cmVhbSk7XG4gIH1cblxuICBzZXJpYWxpemU8VD4oXG4gICAgaW5wdXQ6IEFzeW5jSXRlcmFibGU8VD4sXG4gICAgc2VyaWFsaXplcjogKGV2ZW50OiBUKSA9PiBNZXNzYWdlXG4gICk6IFJlYWRhYmxlIHtcbiAgICAvL3dpbGwgdXNlIFJlYWRhYmxlLmZyb20oSXRlcmFibGUpIGluIE5vZGUxMlxuICAgIGNvbnN0IGlucHV0SXRlcmF0b3IgPSBpbnB1dFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgZ2VuZXJhdG9yRG9uZSA9IGZhbHNlO1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZSh7XG4gICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgYXN5bmMgcmVhZCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpbnB1dEl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmRvbmUgJiYgZ2VuZXJhdG9yRG9uZSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwYXlsb2FkQnVmID0gcmVzdWx0LmRvbmVcbiAgICAgICAgICAgID8gbmV3IFVpbnQ4QXJyYXkoMClcbiAgICAgICAgICAgIDogc2VsZi5ldmVudE1hcnNoYWxsZXIubWFyc2hhbGwoc2VyaWFsaXplcihyZXN1bHQudmFsdWUpKTtcbiAgICAgICAgICB0aGlzLnB1c2gocGF5bG9hZEJ1Zik7XG4gICAgICAgICAgaWYgKHJlc3VsdC5kb25lICYmICFnZW5lcmF0b3JEb25lKSBnZW5lcmF0b3JEb25lID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMuZGVzdHJveShlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8vVE9ETzogdXNlICdhdXRvRGVzdHJveScgd2hlbiB0YXJnZXRpbmcgTm9kZSAxMVxuICAgIC8vcmVmZXJlbmNlOiBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjEzLngvZG9jcy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX25ld19zdHJlYW1fcmVhZGFibGVfb3B0aW9uc1xuICAgIHN0cmVhbS5vbihcImVycm9yXCIsICgpID0+IHtcbiAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgc3RyZWFtLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxufVxuIl19