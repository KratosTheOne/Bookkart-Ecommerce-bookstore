"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
class MessageUnmarshallerStream extends stream_1.Transform {
    constructor(options) {
        super(Object.assign({ readableObjectMode: true, writableObjectMode: true }, options));
        this.eventMarshaller = options.eventMarshaller;
        //TODO: use 'autoDestroy' when targeting Node 11
        //reference: https://nodejs.org/dist/latest-v13.x/docs/api/stream.html#stream_new_stream_readable_options
        this.on("error", () => {
            this.destroy();
        });
        this.on("end", () => {
            this.destroy();
        });
    }
    _transform(chunk, encoding, callback) {
        try {
            const message = this.eventMarshaller.unmarshall(chunk);
            const { value: messageType } = message.headers[":message-type"];
            if (messageType === "error") {
                // Unmodeled exception in event
                const unmodeledError = new Error(message.headers[":error-message"].value || "UnknownError");
                unmodeledError.name = message.headers[":error-code"].value;
                throw unmodeledError;
            }
            else if (messageType === "exception") {
                // For modeled exception, push it to deserializer and throw after deserializing
                this.push({
                    [message.headers[":exception-type"].value]: message
                });
            }
            else if (messageType === "event") {
                this.push({
                    [message.headers[":event-type"].value]: message
                });
            }
            else {
                throw Error(`Unrecognizable event type: ${message.headers[":event-type"].value}`);
            }
            return callback();
        }
        catch (err) {
            callback(err);
        }
    }
}
exports.MessageUnmarshallerStream = MessageUnmarshallerStream;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVzc2FnZVVubWFyc2hhbGxlclN0cmVhbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9NZXNzYWdlVW5tYXJzaGFsbGVyU3RyZWFtLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsbUNBQXdFO0FBT3hFLE1BQWEseUJBQTBCLFNBQVEsa0JBQVM7SUFFdEQsWUFBWSxPQUF5QztRQUNuRCxLQUFLLGlCQUNILGtCQUFrQixFQUFFLElBQUksRUFDeEIsa0JBQWtCLEVBQUUsSUFBSSxJQUNyQixPQUFPLEVBQ1YsQ0FBQztRQUNILElBQUksQ0FBQyxlQUFlLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQztRQUMvQyxnREFBZ0Q7UUFDaEQseUdBQXlHO1FBQ3pHLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRTtZQUNwQixJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDakIsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUU7WUFDbEIsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2pCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELFVBQVUsQ0FBQyxLQUFVLEVBQUUsUUFBZ0IsRUFBRSxRQUEyQjtRQUNsRSxJQUFJO1lBQ0YsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDdkQsTUFBTSxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQ2hFLElBQUksV0FBVyxLQUFLLE9BQU8sRUFBRTtnQkFDM0IsK0JBQStCO2dCQUMvQixNQUFNLGNBQWMsR0FBRyxJQUFJLEtBQUssQ0FDN0IsT0FBTyxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEtBQWdCLElBQUksY0FBYyxDQUN0RSxDQUFDO2dCQUNGLGNBQWMsQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQyxLQUFlLENBQUM7Z0JBQ3JFLE1BQU0sY0FBYyxDQUFDO2FBQ3RCO2lCQUFNLElBQUksV0FBVyxLQUFLLFdBQVcsRUFBRTtnQkFDdEMsK0VBQStFO2dCQUMvRSxJQUFJLENBQUMsSUFBSSxDQUFDO29CQUNSLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEtBQWUsQ0FBQyxFQUFFLE9BQU87aUJBQzlELENBQUMsQ0FBQzthQUNKO2lCQUFNLElBQUksV0FBVyxLQUFLLE9BQU8sRUFBRTtnQkFDbEMsSUFBSSxDQUFDLElBQUksQ0FBQztvQkFDUixDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsS0FBZSxDQUFDLEVBQUUsT0FBTztpQkFDMUQsQ0FBQyxDQUFDO2FBQ0o7aUJBQU07Z0JBQ0wsTUFBTSxLQUFLLENBQ1QsOEJBQThCLE9BQU8sQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQ3JFLENBQUM7YUFDSDtZQUNELE9BQU8sUUFBUSxFQUFFLENBQUM7U0FDbkI7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNaLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNmO0lBQ0gsQ0FBQztDQUNGO0FBakRELDhEQWlEQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYW5zZm9ybSwgVHJhbnNmb3JtT3B0aW9ucywgVHJhbnNmb3JtQ2FsbGJhY2sgfSBmcm9tIFwic3RyZWFtXCI7XG5pbXBvcnQgeyBFdmVudFN0cmVhbU1hcnNoYWxsZXIgYXMgRXZlbnRNYXJzaGFsbGVyIH0gZnJvbSBcIkBhd3Mtc2RrL2V2ZW50c3RyZWFtLW1hcnNoYWxsZXJcIjtcblxuZXhwb3J0IHR5cGUgTWVzc2FnZVVubWFyc2hhbGxlclN0cmVhbU9wdGlvbnMgPSBUcmFuc2Zvcm1PcHRpb25zICYge1xuICBldmVudE1hcnNoYWxsZXI6IEV2ZW50TWFyc2hhbGxlcjtcbn07XG5cbmV4cG9ydCBjbGFzcyBNZXNzYWdlVW5tYXJzaGFsbGVyU3RyZWFtIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgcHJpdmF0ZSByZWFkb25seSBldmVudE1hcnNoYWxsZXI6IEV2ZW50TWFyc2hhbGxlcjtcbiAgY29uc3RydWN0b3Iob3B0aW9uczogTWVzc2FnZVVubWFyc2hhbGxlclN0cmVhbU9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICByZWFkYWJsZU9iamVjdE1vZGU6IHRydWUsXG4gICAgICB3cml0YWJsZU9iamVjdE1vZGU6IHRydWUsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gICAgdGhpcy5ldmVudE1hcnNoYWxsZXIgPSBvcHRpb25zLmV2ZW50TWFyc2hhbGxlcjtcbiAgICAvL1RPRE86IHVzZSAnYXV0b0Rlc3Ryb3knIHdoZW4gdGFyZ2V0aW5nIE5vZGUgMTFcbiAgICAvL3JlZmVyZW5jZTogaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXYxMy54L2RvY3MvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9uZXdfc3RyZWFtX3JlYWRhYmxlX29wdGlvbnNcbiAgICB0aGlzLm9uKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgdGhpcy5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgfVxuXG4gIF90cmFuc2Zvcm0oY2h1bms6IGFueSwgZW5jb2Rpbmc6IHN0cmluZywgY2FsbGJhY2s6IFRyYW5zZm9ybUNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmV2ZW50TWFyc2hhbGxlci51bm1hcnNoYWxsKGNodW5rKTtcbiAgICAgIGNvbnN0IHsgdmFsdWU6IG1lc3NhZ2VUeXBlIH0gPSBtZXNzYWdlLmhlYWRlcnNbXCI6bWVzc2FnZS10eXBlXCJdO1xuICAgICAgaWYgKG1lc3NhZ2VUeXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgLy8gVW5tb2RlbGVkIGV4Y2VwdGlvbiBpbiBldmVudFxuICAgICAgICBjb25zdCB1bm1vZGVsZWRFcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAobWVzc2FnZS5oZWFkZXJzW1wiOmVycm9yLW1lc3NhZ2VcIl0udmFsdWUgYXMgc3RyaW5nKSB8fCBcIlVua25vd25FcnJvclwiXG4gICAgICAgICk7XG4gICAgICAgIHVubW9kZWxlZEVycm9yLm5hbWUgPSBtZXNzYWdlLmhlYWRlcnNbXCI6ZXJyb3ItY29kZVwiXS52YWx1ZSBhcyBzdHJpbmc7XG4gICAgICAgIHRocm93IHVubW9kZWxlZEVycm9yO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlVHlwZSA9PT0gXCJleGNlcHRpb25cIikge1xuICAgICAgICAvLyBGb3IgbW9kZWxlZCBleGNlcHRpb24sIHB1c2ggaXQgdG8gZGVzZXJpYWxpemVyIGFuZCB0aHJvdyBhZnRlciBkZXNlcmlhbGl6aW5nXG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgW21lc3NhZ2UuaGVhZGVyc1tcIjpleGNlcHRpb24tdHlwZVwiXS52YWx1ZSBhcyBzdHJpbmddOiBtZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlVHlwZSA9PT0gXCJldmVudFwiKSB7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgW21lc3NhZ2UuaGVhZGVyc1tcIjpldmVudC10eXBlXCJdLnZhbHVlIGFzIHN0cmluZ106IG1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBgVW5yZWNvZ25pemFibGUgZXZlbnQgdHlwZTogJHttZXNzYWdlLmhlYWRlcnNbXCI6ZXZlbnQtdHlwZVwiXS52YWx1ZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICB9XG59XG4iXX0=