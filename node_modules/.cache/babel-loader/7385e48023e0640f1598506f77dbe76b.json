{"ast":null,"code":"import { ALWAYS_UNSIGNABLE_HEADERS, PROXY_HEADER_PATTERN, SEC_HEADER_PATTERN } from \"./constants\";\n/**\n * @internal\n */\n\nexport function getCanonicalHeaders(_a, unsignableHeaders, signableHeaders) {\n  var headers = _a.headers;\n  var canonical = {};\n\n  for (var _i = 0, _b = Object.keys(headers).sort(); _i < _b.length; _i++) {\n    var headerName = _b[_i];\n    var canonicalHeaderName = headerName.toLowerCase();\n\n    if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || (unsignableHeaders === null || unsignableHeaders === void 0 ? void 0 : unsignableHeaders.has(canonicalHeaderName)) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {\n      if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {\n        continue;\n      }\n    }\n\n    canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\\s+/g, \" \");\n  }\n\n  return canonical;\n}","map":{"version":3,"sources":["../../src/getCanonicalHeaders.ts"],"names":[],"mappings":"AACA,SACE,yBADF,EAEE,oBAFF,EAGE,kBAHF,QAIO,aAJP;AAMA;;;;AAGA,OAAM,SAAU,mBAAV,CACJ,EADI,EAEJ,iBAFI,EAGJ,eAHI,EAGyB;MAF3B,OAAA,GAAA,EAAA,CAAA,O;AAIF,MAAM,SAAS,GAAc,EAA7B;;AACA,OAAuB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,IAArB,EAAvB,EAAuB,EAAA,GAAA,EAAA,CAAA,MAAvB,EAAuB,EAAA,EAAvB,EAAoD;AAA/C,QAAI,UAAU,GAAA,EAAA,CAAA,EAAA,CAAd;AACH,QAAM,mBAAmB,GAAG,UAAU,CAAC,WAAX,EAA5B;;AACA,QACE,mBAAmB,IAAI,yBAAvB,KACA,iBAAiB,KAAA,IAAjB,IAAA,iBAAiB,KAAA,KAAA,CAAjB,GAAiB,KAAA,CAAjB,GAAA,iBAAiB,CAAE,GAAnB,CAAuB,mBAAvB,CADA,KAEA,oBAAoB,CAAC,IAArB,CAA0B,mBAA1B,CAFA,IAGA,kBAAkB,CAAC,IAAnB,CAAwB,mBAAxB,CAJF,EAKE;AACA,UACE,CAAC,eAAD,IACC,eAAe,IAAI,CAAC,eAAe,CAAC,GAAhB,CAAoB,mBAApB,CAFvB,EAGE;AACA;AACD;AACF;;AAED,IAAA,SAAS,CAAC,mBAAD,CAAT,GAAiC,OAAO,CAAC,UAAD,CAAP,CAC9B,IAD8B,GAE9B,OAF8B,CAEtB,MAFsB,EAEd,GAFc,CAAjC;AAGD;;AAED,SAAO,SAAP;AACD","sourceRoot":"","sourcesContent":["import { ALWAYS_UNSIGNABLE_HEADERS, PROXY_HEADER_PATTERN, SEC_HEADER_PATTERN } from \"./constants\";\n/**\n * @internal\n */\nexport function getCanonicalHeaders(_a, unsignableHeaders, signableHeaders) {\n    var headers = _a.headers;\n    var canonical = {};\n    for (var _i = 0, _b = Object.keys(headers).sort(); _i < _b.length; _i++) {\n        var headerName = _b[_i];\n        var canonicalHeaderName = headerName.toLowerCase();\n        if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || (unsignableHeaders === null || unsignableHeaders === void 0 ? void 0 : unsignableHeaders.has(canonicalHeaderName)) ||\n            PROXY_HEADER_PATTERN.test(canonicalHeaderName) ||\n            SEC_HEADER_PATTERN.test(canonicalHeaderName)) {\n            if (!signableHeaders ||\n                (signableHeaders && !signableHeaders.has(canonicalHeaderName))) {\n                continue;\n            }\n        }\n        canonical[canonicalHeaderName] = headers[headerName]\n            .trim()\n            .replace(/\\s+/g, \" \");\n    }\n    return canonical;\n}\n//# sourceMappingURL=getCanonicalHeaders.js.map"]},"metadata":{},"sourceType":"module"}