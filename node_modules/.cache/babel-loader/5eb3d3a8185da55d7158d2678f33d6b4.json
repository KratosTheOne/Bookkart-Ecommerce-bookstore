{"ast":null,"code":"import { __read } from \"tslib\";\nimport { DOT_PATTERN, getArnResources, getSuffix, getSuffixForArnEndpoint, isBucketNameOptions, isDnsCompatibleBucketName, S3_HOSTNAME_PATTERN, validateAccountId, validateArnEndpointOptions, validateDNSHostLabel, validateNoDualstack, validateNoFIPS, validateOutpostService, validatePartition, validateRegion, validateS3Service, validateService } from \"./bucketHostnameUtils\";\nexport var bucketHostname = function (options) {\n  var baseHostname = options.baseHostname;\n\n  if (!S3_HOSTNAME_PATTERN.test(baseHostname)) {\n    return {\n      bucketEndpoint: false,\n      hostname: baseHostname\n    };\n  }\n\n  return isBucketNameOptions(options) ? // Construct endpoint when bucketName is a string referring to a bucket name\n  getEndpointFromBucketName(options) : // Construct endpoint when bucketName is an ARN referring to an S3 resource like Access Point\n  getEndpointFromArn(options);\n};\n\nvar getEndpointFromArn = function (options) {\n  // Infer client region and hostname suffix from hostname from endpoints.json, like `s3.us-west-2.amazonaws.com`\n  var _a = __read(getSuffixForArnEndpoint(options.baseHostname), 2),\n      clientRegion = _a[0],\n      hostnameSuffix = _a[1];\n\n  var pathStyleEndpoint = options.pathStyleEndpoint,\n      _b = options.dualstackEndpoint,\n      dualstackEndpoint = _b === void 0 ? false : _b,\n      _c = options.accelerateEndpoint,\n      accelerateEndpoint = _c === void 0 ? false : _c,\n      _d = options.tlsCompatible,\n      tlsCompatible = _d === void 0 ? true : _d,\n      useArnRegion = options.useArnRegion,\n      bucketName = options.bucketName,\n      _e = options.clientPartition,\n      clientPartition = _e === void 0 ? \"aws\" : _e,\n      _f = options.clientSigningRegion,\n      clientSigningRegion = _f === void 0 ? clientRegion : _f;\n  validateArnEndpointOptions({\n    pathStyleEndpoint: pathStyleEndpoint,\n    accelerateEndpoint: accelerateEndpoint,\n    tlsCompatible: tlsCompatible\n  }); // Validate and parse the ARN supplied as a bucket name\n\n  var service = bucketName.service,\n      partition = bucketName.partition,\n      accountId = bucketName.accountId,\n      region = bucketName.region,\n      resource = bucketName.resource;\n  validateService(service);\n  validatePartition(partition, {\n    clientPartition: clientPartition\n  });\n  validateAccountId(accountId);\n  validateRegion(region, {\n    useArnRegion: useArnRegion,\n    clientRegion: clientRegion,\n    clientSigningRegion: clientSigningRegion\n  });\n\n  var _g = getArnResources(resource),\n      accesspointName = _g.accesspointName,\n      outpostId = _g.outpostId;\n\n  validateDNSHostLabel(accesspointName + \"-\" + accountId, {\n    tlsCompatible: tlsCompatible\n  });\n  var endpointRegion = useArnRegion ? region : clientRegion;\n  var signingRegion = useArnRegion ? region : clientSigningRegion;\n\n  if (outpostId) {\n    // if this is an Outpost ARN\n    validateOutpostService(service);\n    validateDNSHostLabel(outpostId, {\n      tlsCompatible: tlsCompatible\n    });\n    validateNoDualstack(dualstackEndpoint);\n    validateNoFIPS(endpointRegion);\n    return {\n      bucketEndpoint: true,\n      hostname: accesspointName + \"-\" + accountId + \".\" + outpostId + \".s3-outposts.\" + endpointRegion + \".\" + hostnameSuffix,\n      signingRegion: signingRegion,\n      signingService: \"s3-outposts\"\n    };\n  } // construct endpoint from Accesspoint ARN\n\n\n  validateS3Service(service);\n  return {\n    bucketEndpoint: true,\n    hostname: accesspointName + \"-\" + accountId + \".s3-accesspoint\" + (dualstackEndpoint ? \".dualstack\" : \"\") + \".\" + endpointRegion + \".\" + hostnameSuffix,\n    signingRegion: signingRegion\n  };\n};\n\nvar getEndpointFromBucketName = function (_a) {\n  var _b = _a.accelerateEndpoint,\n      accelerateEndpoint = _b === void 0 ? false : _b,\n      baseHostname = _a.baseHostname,\n      bucketName = _a.bucketName,\n      _c = _a.dualstackEndpoint,\n      dualstackEndpoint = _c === void 0 ? false : _c,\n      _d = _a.pathStyleEndpoint,\n      pathStyleEndpoint = _d === void 0 ? false : _d,\n      _e = _a.tlsCompatible,\n      tlsCompatible = _e === void 0 ? true : _e;\n\n  var _f = __read(getSuffix(baseHostname), 2),\n      clientRegion = _f[0],\n      hostnameSuffix = _f[1];\n\n  if (pathStyleEndpoint || !isDnsCompatibleBucketName(bucketName) || tlsCompatible && DOT_PATTERN.test(bucketName)) {\n    return {\n      bucketEndpoint: false,\n      hostname: dualstackEndpoint ? \"s3.dualstack.\" + clientRegion + \".\" + hostnameSuffix : baseHostname\n    };\n  }\n\n  if (accelerateEndpoint) {\n    baseHostname = \"s3-accelerate\" + (dualstackEndpoint ? \".dualstack\" : \"\") + \".\" + hostnameSuffix;\n  } else if (dualstackEndpoint) {\n    baseHostname = \"s3.dualstack.\" + clientRegion + \".\" + hostnameSuffix;\n  }\n\n  return {\n    bucketEndpoint: true,\n    hostname: bucketName + \".\" + baseHostname\n  };\n};","map":{"version":3,"sources":["../../src/bucketHostname.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ArnHostnameParams,\n  BucketHostnameParams,\n  DOT_PATTERN,\n  getArnResources,\n  getSuffix,\n  getSuffixForArnEndpoint,\n  isBucketNameOptions,\n  isDnsCompatibleBucketName,\n  S3_HOSTNAME_PATTERN,\n  validateAccountId,\n  validateArnEndpointOptions,\n  validateDNSHostLabel,\n  validateNoDualstack,\n  validateNoFIPS,\n  validateOutpostService,\n  validatePartition,\n  validateRegion,\n  validateS3Service,\n  validateService,\n} from \"./bucketHostnameUtils\";\n\nexport interface BucketHostname {\n  hostname: string;\n  bucketEndpoint: boolean;\n  signingRegion?: string;\n  signingService?: string;\n}\n\nexport const bucketHostname = (options: BucketHostnameParams | ArnHostnameParams): BucketHostname => {\n  const { baseHostname } = options;\n  if (!S3_HOSTNAME_PATTERN.test(baseHostname)) {\n    return {\n      bucketEndpoint: false,\n      hostname: baseHostname,\n    };\n  }\n  return isBucketNameOptions(options)\n    ? // Construct endpoint when bucketName is a string referring to a bucket name\n      getEndpointFromBucketName(options)\n    : // Construct endpoint when bucketName is an ARN referring to an S3 resource like Access Point\n      getEndpointFromArn(options);\n};\n\nconst getEndpointFromArn = (options: ArnHostnameParams): BucketHostname => {\n  // Infer client region and hostname suffix from hostname from endpoints.json, like `s3.us-west-2.amazonaws.com`\n  const [clientRegion, hostnameSuffix] = getSuffixForArnEndpoint(options.baseHostname);\n  const {\n    pathStyleEndpoint,\n    dualstackEndpoint = false,\n    accelerateEndpoint = false,\n    tlsCompatible = true,\n    useArnRegion,\n    bucketName,\n    clientPartition = \"aws\",\n    clientSigningRegion = clientRegion,\n  } = options;\n\n  validateArnEndpointOptions({ pathStyleEndpoint, accelerateEndpoint, tlsCompatible });\n\n  // Validate and parse the ARN supplied as a bucket name\n  const { service, partition, accountId, region, resource } = bucketName;\n  validateService(service);\n  validatePartition(partition, { clientPartition });\n  validateAccountId(accountId);\n  validateRegion(region, { useArnRegion, clientRegion, clientSigningRegion });\n  const { accesspointName, outpostId } = getArnResources(resource);\n  validateDNSHostLabel(`${accesspointName}-${accountId}`, { tlsCompatible });\n\n  const endpointRegion = useArnRegion ? region : clientRegion;\n  const signingRegion = useArnRegion ? region : clientSigningRegion;\n  if (outpostId) {\n    // if this is an Outpost ARN\n    validateOutpostService(service);\n    validateDNSHostLabel(outpostId, { tlsCompatible });\n    validateNoDualstack(dualstackEndpoint);\n    validateNoFIPS(endpointRegion);\n    return {\n      bucketEndpoint: true,\n      hostname: `${accesspointName}-${accountId}.${outpostId}.s3-outposts.${endpointRegion}.${hostnameSuffix}`,\n      signingRegion,\n      signingService: \"s3-outposts\",\n    };\n  }\n  // construct endpoint from Accesspoint ARN\n  validateS3Service(service);\n  return {\n    bucketEndpoint: true,\n    hostname: `${accesspointName}-${accountId}.s3-accesspoint${\n      dualstackEndpoint ? \".dualstack\" : \"\"\n    }.${endpointRegion}.${hostnameSuffix}`,\n    signingRegion,\n  };\n};\n\nconst getEndpointFromBucketName = ({\n  accelerateEndpoint = false,\n  baseHostname,\n  bucketName,\n  dualstackEndpoint = false,\n  pathStyleEndpoint = false,\n  tlsCompatible = true,\n}: BucketHostnameParams): BucketHostname => {\n  const [clientRegion, hostnameSuffix] = getSuffix(baseHostname);\n  if (pathStyleEndpoint || !isDnsCompatibleBucketName(bucketName) || (tlsCompatible && DOT_PATTERN.test(bucketName))) {\n    return {\n      bucketEndpoint: false,\n      hostname: dualstackEndpoint ? `s3.dualstack.${clientRegion}.${hostnameSuffix}` : baseHostname,\n    };\n  }\n\n  if (accelerateEndpoint) {\n    baseHostname = `s3-accelerate${dualstackEndpoint ? \".dualstack\" : \"\"}.${hostnameSuffix}`;\n  } else if (dualstackEndpoint) {\n    baseHostname = `s3.dualstack.${clientRegion}.${hostnameSuffix}`;\n  }\n\n  return {\n    bucketEndpoint: true,\n    hostname: `${bucketName}.${baseHostname}`,\n  };\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}