{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER } from \"./constants\";\nimport { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { hasHeader } from \"./hasHeader\";\nimport { iso8601 } from \"./utilDate\";\n\nvar SignatureV4 =\n/** @class */\nfunction () {\n  function SignatureV4(_a) {\n    var applyChecksum = _a.applyChecksum,\n        credentials = _a.credentials,\n        region = _a.region,\n        service = _a.service,\n        sha256 = _a.sha256,\n        _b = _a.uriEscapePath,\n        uriEscapePath = _b === void 0 ? true : _b;\n    this.service = service;\n    this.sha256 = sha256;\n    this.uriEscapePath = uriEscapePath; // default to true if applyChecksum isn't set\n\n    this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n\n    if (typeof region === \"string\") {\n      var promisified_1 = Promise.resolve(region);\n\n      this.regionProvider = function () {\n        return promisified_1;\n      };\n    } else {\n      this.regionProvider = region;\n    }\n\n    if (typeof credentials === \"object\") {\n      var promisified_2 = Promise.resolve(credentials);\n\n      this.credentialProvider = function () {\n        return promisified_2;\n      };\n    } else {\n      this.credentialProvider = credentials;\n    }\n  }\n\n  SignatureV4.prototype.presign = function (originalRequest, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, region, credentials, _b, signingDate, _c, expiresIn, unsignableHeaders, signableHeaders, _d, longDate, shortDate, scope, request, canonicalHeaders, _e, _f, _g, _h, _j, _k;\n\n      return __generator(this, function (_l) {\n        switch (_l.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Promise.all([this.regionProvider(), this.credentialProvider()])];\n\n          case 1:\n            _a = _l.sent(), region = _a[0], credentials = _a[1];\n            _b = options.signingDate, signingDate = _b === void 0 ? new Date() : _b, _c = options.expiresIn, expiresIn = _c === void 0 ? 3600 : _c, unsignableHeaders = options.unsignableHeaders, signableHeaders = options.signableHeaders;\n            _d = formatDate(signingDate), longDate = _d.longDate, shortDate = _d.shortDate;\n\n            if (expiresIn > MAX_PRESIGNED_TTL) {\n              return [2\n              /*return*/\n              , Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\")];\n            }\n\n            scope = createScope(shortDate, region, this.service);\n            request = moveHeadersToQuery(prepareRequest(originalRequest));\n\n            if (credentials.sessionToken) {\n              request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n            }\n\n            request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n            request.query[CREDENTIAL_QUERY_PARAM] = credentials.accessKeyId + \"/\" + scope;\n            request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n            request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n            canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n            request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n            _e = request.query;\n            _f = SIGNATURE_QUERY_PARAM;\n            _g = this.getSignature;\n            _h = [longDate, scope, this.getSigningKey(credentials, region, shortDate)];\n            _j = this.createCanonicalRequest;\n            _k = [request, canonicalHeaders];\n            return [4\n            /*yield*/\n            , getPayloadHash(originalRequest, this.sha256)];\n\n          case 2:\n            return [4\n            /*yield*/\n            , _g.apply(this, _h.concat([_j.apply(this, _k.concat([_l.sent()]))]))];\n\n          case 3:\n            _e[_f] = _l.sent();\n            return [2\n            /*return*/\n            , request];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.sign = function (toSign, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (typeof toSign === \"string\") {\n          return [2\n          /*return*/\n          , this.signString(toSign, options)];\n        } else if (toSign.headers && toSign.payload) {\n          return [2\n          /*return*/\n          , this.signEvent(toSign, options)];\n        } else {\n          return [2\n          /*return*/\n          , this.signRequest(toSign, options)];\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  SignatureV4.prototype.signEvent = function (_a, _b) {\n    var headers = _a.headers,\n        payload = _a.payload;\n    var _c = _b.signingDate,\n        signingDate = _c === void 0 ? new Date() : _c,\n        priorSignature = _b.priorSignature;\n    return __awaiter(this, void 0, void 0, function () {\n      var region, _d, shortDate, longDate, scope, hashedPayload, hash, hashedHeaders, _e, stringToSign;\n\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Promise.all([this.regionProvider(), this.credentialProvider()])];\n\n          case 1:\n            region = _f.sent()[0];\n            _d = formatDate(signingDate), shortDate = _d.shortDate, longDate = _d.longDate;\n            scope = createScope(shortDate, region, this.service);\n            return [4\n            /*yield*/\n            , getPayloadHash({\n              headers: {},\n              body: payload\n            }, this.sha256)];\n\n          case 2:\n            hashedPayload = _f.sent();\n            hash = new this.sha256();\n            hash.update(headers);\n            _e = toHex;\n            return [4\n            /*yield*/\n            , hash.digest()];\n\n          case 3:\n            hashedHeaders = _e.apply(void 0, [_f.sent()]);\n            stringToSign = [EVENT_ALGORITHM_IDENTIFIER, longDate, scope, priorSignature, hashedHeaders, hashedPayload].join(\"\\n\");\n            return [2\n            /*return*/\n            , this.signString(stringToSign, {\n              signingDate: signingDate\n            })];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.signString = function (stringToSign, _a) {\n    var _b = (_a === void 0 ? {} : _a).signingDate,\n        signingDate = _b === void 0 ? new Date() : _b;\n    return __awaiter(this, void 0, void 0, function () {\n      var _c, region, credentials, shortDate, hash, _d, _e, _f;\n\n      return __generator(this, function (_g) {\n        switch (_g.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Promise.all([this.regionProvider(), this.credentialProvider()])];\n\n          case 1:\n            _c = _g.sent(), region = _c[0], credentials = _c[1];\n            shortDate = formatDate(signingDate).shortDate;\n            _e = (_d = this.sha256).bind;\n            return [4\n            /*yield*/\n            , this.getSigningKey(credentials, region, shortDate)];\n\n          case 2:\n            hash = new (_e.apply(_d, [void 0, _g.sent()]))();\n            hash.update(stringToSign);\n            _f = toHex;\n            return [4\n            /*yield*/\n            , hash.digest()];\n\n          case 3:\n            return [2\n            /*return*/\n            , _f.apply(void 0, [_g.sent()])];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.signRequest = function (requestToSign, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.signingDate,\n        signingDate = _c === void 0 ? new Date() : _c,\n        signableHeaders = _b.signableHeaders,\n        unsignableHeaders = _b.unsignableHeaders;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _d, region, credentials, request, _e, longDate, shortDate, scope, payloadHash, canonicalHeaders, signature;\n\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Promise.all([this.regionProvider(), this.credentialProvider()])];\n\n          case 1:\n            _d = _f.sent(), region = _d[0], credentials = _d[1];\n            request = prepareRequest(requestToSign);\n            _e = formatDate(signingDate), longDate = _e.longDate, shortDate = _e.shortDate;\n            scope = createScope(shortDate, region, this.service);\n            request.headers[AMZ_DATE_HEADER] = longDate;\n\n            if (credentials.sessionToken) {\n              request.headers[TOKEN_HEADER] = credentials.sessionToken;\n            }\n\n            return [4\n            /*yield*/\n            , getPayloadHash(request, this.sha256)];\n\n          case 2:\n            payloadHash = _f.sent();\n\n            if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n              request.headers[SHA256_HEADER] = payloadHash;\n            }\n\n            canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n            return [4\n            /*yield*/\n            , this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate), this.createCanonicalRequest(request, canonicalHeaders, payloadHash))];\n\n          case 3:\n            signature = _f.sent();\n            request.headers[AUTH_HEADER] = ALGORITHM_IDENTIFIER + \" \" + (\"Credential=\" + credentials.accessKeyId + \"/\" + scope + \", \") + (\"SignedHeaders=\" + getCanonicalHeaderList(canonicalHeaders) + \", \") + (\"Signature=\" + signature);\n            return [2\n            /*return*/\n            , request];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.createCanonicalRequest = function (request, canonicalHeaders, payloadHash) {\n    var sortedHeaders = Object.keys(canonicalHeaders).sort();\n    return request.method + \"\\n\" + this.getCanonicalPath(request) + \"\\n\" + getCanonicalQuery(request) + \"\\n\" + sortedHeaders.map(function (name) {\n      return name + \":\" + canonicalHeaders[name];\n    }).join(\"\\n\") + \"\\n\\n\" + sortedHeaders.join(\";\") + \"\\n\" + payloadHash;\n  };\n\n  SignatureV4.prototype.createStringToSign = function (longDate, credentialScope, canonicalRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var hash, hashedRequest;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            hash = new this.sha256();\n            hash.update(canonicalRequest);\n            return [4\n            /*yield*/\n            , hash.digest()];\n\n          case 1:\n            hashedRequest = _a.sent();\n            return [2\n            /*return*/\n            , ALGORITHM_IDENTIFIER + \"\\n\" + longDate + \"\\n\" + credentialScope + \"\\n\" + toHex(hashedRequest)];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.getCanonicalPath = function (_a) {\n    var path = _a.path;\n\n    if (this.uriEscapePath) {\n      var doubleEncoded = encodeURIComponent(path.replace(/^\\//, \"\"));\n      return \"/\" + doubleEncoded.replace(/%2F/g, \"/\");\n    }\n\n    return path;\n  };\n\n  SignatureV4.prototype.getSignature = function (longDate, credentialScope, keyPromise, canonicalRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var stringToSign, hash, _a, _b, _c;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.createStringToSign(longDate, credentialScope, canonicalRequest)];\n\n          case 1:\n            stringToSign = _d.sent();\n            _b = (_a = this.sha256).bind;\n            return [4\n            /*yield*/\n            , keyPromise];\n\n          case 2:\n            hash = new (_b.apply(_a, [void 0, _d.sent()]))();\n            hash.update(stringToSign);\n            _c = toHex;\n            return [4\n            /*yield*/\n            , hash.digest()];\n\n          case 3:\n            return [2\n            /*return*/\n            , _c.apply(void 0, [_d.sent()])];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.getSigningKey = function (credentials, region, shortDate) {\n    return getSigningKey(this.sha256, credentials, shortDate, region, this.service);\n  };\n\n  return SignatureV4;\n}();\n\nexport { SignatureV4 };\n\nfunction formatDate(now) {\n  var longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n  return {\n    longDate: longDate,\n    shortDate: longDate.substr(0, 8)\n  };\n}\n\nfunction getCanonicalHeaderList(headers) {\n  return Object.keys(headers).sort().join(\";\");\n}","map":{"version":3,"sources":["../../src/SignatureV4.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __generator } from \"tslib\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER } from \"./constants\";\nimport { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { hasHeader } from \"./hasHeader\";\nimport { iso8601 } from \"./utilDate\";\nvar SignatureV4 = /** @class */ (function () {\n    function SignatureV4(_a) {\n        var applyChecksum = _a.applyChecksum, credentials = _a.credentials, region = _a.region, service = _a.service, sha256 = _a.sha256, _b = _a.uriEscapePath, uriEscapePath = _b === void 0 ? true : _b;\n        this.service = service;\n        this.sha256 = sha256;\n        this.uriEscapePath = uriEscapePath;\n        // default to true if applyChecksum isn't set\n        this.applyChecksum =\n            typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n        if (typeof region === \"string\") {\n            var promisified_1 = Promise.resolve(region);\n            this.regionProvider = function () { return promisified_1; };\n        }\n        else {\n            this.regionProvider = region;\n        }\n        if (typeof credentials === \"object\") {\n            var promisified_2 = Promise.resolve(credentials);\n            this.credentialProvider = function () { return promisified_2; };\n        }\n        else {\n            this.credentialProvider = credentials;\n        }\n    }\n    SignatureV4.prototype.presign = function (originalRequest, options) {\n        if (options === void 0) { options = {}; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, region, credentials, _b, signingDate, _c, expiresIn, unsignableHeaders, signableHeaders, _d, longDate, shortDate, scope, request, canonicalHeaders, _e, _f, _g, _h, _j, _k;\n            return __generator(this, function (_l) {\n                switch (_l.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.regionProvider(),\n                            this.credentialProvider()\n                        ])];\n                    case 1:\n                        _a = _l.sent(), region = _a[0], credentials = _a[1];\n                        _b = options.signingDate, signingDate = _b === void 0 ? new Date() : _b, _c = options.expiresIn, expiresIn = _c === void 0 ? 3600 : _c, unsignableHeaders = options.unsignableHeaders, signableHeaders = options.signableHeaders;\n                        _d = formatDate(signingDate), longDate = _d.longDate, shortDate = _d.shortDate;\n                        if (expiresIn > MAX_PRESIGNED_TTL) {\n                            return [2 /*return*/, Promise.reject(\"Signature version 4 presigned URLs\" +\n                                    \" must have an expiration date less than one week in\" +\n                                    \" the future\")];\n                        }\n                        scope = createScope(shortDate, region, this.service);\n                        request = moveHeadersToQuery(prepareRequest(originalRequest));\n                        if (credentials.sessionToken) {\n                            request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n                        }\n                        request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n                        request.query[CREDENTIAL_QUERY_PARAM] = credentials.accessKeyId + \"/\" + scope;\n                        request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n                        request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n                        canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n                        request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n                        _e = request.query;\n                        _f = SIGNATURE_QUERY_PARAM;\n                        _g = this.getSignature;\n                        _h = [longDate,\n                            scope,\n                            this.getSigningKey(credentials, region, shortDate)];\n                        _j = this.createCanonicalRequest;\n                        _k = [request,\n                            canonicalHeaders];\n                        return [4 /*yield*/, getPayloadHash(originalRequest, this.sha256)];\n                    case 2: return [4 /*yield*/, _g.apply(this, _h.concat([_j.apply(this, _k.concat([_l.sent()]))]))];\n                    case 3:\n                        _e[_f] = _l.sent();\n                        return [2 /*return*/, request];\n                }\n            });\n        });\n    };\n    SignatureV4.prototype.sign = function (toSign, options) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (typeof toSign === \"string\") {\n                    return [2 /*return*/, this.signString(toSign, options)];\n                }\n                else if (toSign.headers && toSign.payload) {\n                    return [2 /*return*/, this.signEvent(toSign, options)];\n                }\n                else {\n                    return [2 /*return*/, this.signRequest(toSign, options)];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    SignatureV4.prototype.signEvent = function (_a, _b) {\n        var headers = _a.headers, payload = _a.payload;\n        var _c = _b.signingDate, signingDate = _c === void 0 ? new Date() : _c, priorSignature = _b.priorSignature;\n        return __awaiter(this, void 0, void 0, function () {\n            var region, _d, shortDate, longDate, scope, hashedPayload, hash, hashedHeaders, _e, stringToSign;\n            return __generator(this, function (_f) {\n                switch (_f.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.regionProvider(),\n                            this.credentialProvider()\n                        ])];\n                    case 1:\n                        region = (_f.sent())[0];\n                        _d = formatDate(signingDate), shortDate = _d.shortDate, longDate = _d.longDate;\n                        scope = createScope(shortDate, region, this.service);\n                        return [4 /*yield*/, getPayloadHash({ headers: {}, body: payload }, this.sha256)];\n                    case 2:\n                        hashedPayload = _f.sent();\n                        hash = new this.sha256();\n                        hash.update(headers);\n                        _e = toHex;\n                        return [4 /*yield*/, hash.digest()];\n                    case 3:\n                        hashedHeaders = _e.apply(void 0, [_f.sent()]);\n                        stringToSign = [\n                            EVENT_ALGORITHM_IDENTIFIER,\n                            longDate,\n                            scope,\n                            priorSignature,\n                            hashedHeaders,\n                            hashedPayload\n                        ].join(\"\\n\");\n                        return [2 /*return*/, this.signString(stringToSign, { signingDate: signingDate })];\n                }\n            });\n        });\n    };\n    SignatureV4.prototype.signString = function (stringToSign, _a) {\n        var _b = (_a === void 0 ? {} : _a).signingDate, signingDate = _b === void 0 ? new Date() : _b;\n        return __awaiter(this, void 0, void 0, function () {\n            var _c, region, credentials, shortDate, hash, _d, _e, _f;\n            return __generator(this, function (_g) {\n                switch (_g.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.regionProvider(),\n                            this.credentialProvider()\n                        ])];\n                    case 1:\n                        _c = _g.sent(), region = _c[0], credentials = _c[1];\n                        shortDate = formatDate(signingDate).shortDate;\n                        _e = (_d = this.sha256).bind;\n                        return [4 /*yield*/, this.getSigningKey(credentials, region, shortDate)];\n                    case 2:\n                        hash = new (_e.apply(_d, [void 0, _g.sent()]))();\n                        hash.update(stringToSign);\n                        _f = toHex;\n                        return [4 /*yield*/, hash.digest()];\n                    case 3: return [2 /*return*/, _f.apply(void 0, [_g.sent()])];\n                }\n            });\n        });\n    };\n    SignatureV4.prototype.signRequest = function (requestToSign, _a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.signingDate, signingDate = _c === void 0 ? new Date() : _c, signableHeaders = _b.signableHeaders, unsignableHeaders = _b.unsignableHeaders;\n        return __awaiter(this, void 0, void 0, function () {\n            var _d, region, credentials, request, _e, longDate, shortDate, scope, payloadHash, canonicalHeaders, signature;\n            return __generator(this, function (_f) {\n                switch (_f.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.regionProvider(),\n                            this.credentialProvider()\n                        ])];\n                    case 1:\n                        _d = _f.sent(), region = _d[0], credentials = _d[1];\n                        request = prepareRequest(requestToSign);\n                        _e = formatDate(signingDate), longDate = _e.longDate, shortDate = _e.shortDate;\n                        scope = createScope(shortDate, region, this.service);\n                        request.headers[AMZ_DATE_HEADER] = longDate;\n                        if (credentials.sessionToken) {\n                            request.headers[TOKEN_HEADER] = credentials.sessionToken;\n                        }\n                        return [4 /*yield*/, getPayloadHash(request, this.sha256)];\n                    case 2:\n                        payloadHash = _f.sent();\n                        if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n                            request.headers[SHA256_HEADER] = payloadHash;\n                        }\n                        canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n                        return [4 /*yield*/, this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate), this.createCanonicalRequest(request, canonicalHeaders, payloadHash))];\n                    case 3:\n                        signature = _f.sent();\n                        request.headers[AUTH_HEADER] =\n                            ALGORITHM_IDENTIFIER + \" \" +\n                                (\"Credential=\" + credentials.accessKeyId + \"/\" + scope + \", \") +\n                                (\"SignedHeaders=\" + getCanonicalHeaderList(canonicalHeaders) + \", \") +\n                                (\"Signature=\" + signature);\n                        return [2 /*return*/, request];\n                }\n            });\n        });\n    };\n    SignatureV4.prototype.createCanonicalRequest = function (request, canonicalHeaders, payloadHash) {\n        var sortedHeaders = Object.keys(canonicalHeaders).sort();\n        return request.method + \"\\n\" + this.getCanonicalPath(request) + \"\\n\" + getCanonicalQuery(request) + \"\\n\" + sortedHeaders.map(function (name) { return name + \":\" + canonicalHeaders[name]; }).join(\"\\n\") + \"\\n\\n\" + sortedHeaders.join(\";\") + \"\\n\" + payloadHash;\n    };\n    SignatureV4.prototype.createStringToSign = function (longDate, credentialScope, canonicalRequest) {\n        return __awaiter(this, void 0, void 0, function () {\n            var hash, hashedRequest;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        hash = new this.sha256();\n                        hash.update(canonicalRequest);\n                        return [4 /*yield*/, hash.digest()];\n                    case 1:\n                        hashedRequest = _a.sent();\n                        return [2 /*return*/, ALGORITHM_IDENTIFIER + \"\\n\" + longDate + \"\\n\" + credentialScope + \"\\n\" + toHex(hashedRequest)];\n                }\n            });\n        });\n    };\n    SignatureV4.prototype.getCanonicalPath = function (_a) {\n        var path = _a.path;\n        if (this.uriEscapePath) {\n            var doubleEncoded = encodeURIComponent(path.replace(/^\\//, \"\"));\n            return \"/\" + doubleEncoded.replace(/%2F/g, \"/\");\n        }\n        return path;\n    };\n    SignatureV4.prototype.getSignature = function (longDate, credentialScope, keyPromise, canonicalRequest) {\n        return __awaiter(this, void 0, void 0, function () {\n            var stringToSign, hash, _a, _b, _c;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0: return [4 /*yield*/, this.createStringToSign(longDate, credentialScope, canonicalRequest)];\n                    case 1:\n                        stringToSign = _d.sent();\n                        _b = (_a = this.sha256).bind;\n                        return [4 /*yield*/, keyPromise];\n                    case 2:\n                        hash = new (_b.apply(_a, [void 0, _d.sent()]))();\n                        hash.update(stringToSign);\n                        _c = toHex;\n                        return [4 /*yield*/, hash.digest()];\n                    case 3: return [2 /*return*/, _c.apply(void 0, [_d.sent()])];\n                }\n            });\n        });\n    };\n    SignatureV4.prototype.getSigningKey = function (credentials, region, shortDate) {\n        return getSigningKey(this.sha256, credentials, shortDate, region, this.service);\n    };\n    return SignatureV4;\n}());\nexport { SignatureV4 };\nfunction formatDate(now) {\n    var longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n    return {\n        longDate: longDate,\n        shortDate: longDate.substr(0, 8)\n    };\n}\nfunction getCanonicalHeaderList(headers) {\n    return Object.keys(headers).sort().join(\";\");\n}\n//# sourceMappingURL=SignatureV4.js.map"]},"metadata":{},"sourceType":"module"}