{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar buffer_1 = require(\"buffer\");\n\nvar is_array_buffer_1 = require(\"@aws-sdk/is-array-buffer\");\n\nfunction fromArrayBuffer(input, offset, length) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  if (length === void 0) {\n    length = input.byteLength - offset;\n  }\n\n  if (!is_array_buffer_1.isArrayBuffer(input)) {\n    throw new Error(\"argument passed to fromArrayBuffer was not an ArrayBuffer\");\n  }\n\n  if (typeof buffer_1.Buffer.from === \"function\" && buffer_1.Buffer.from !== Uint8Array.from) {\n    return buffer_1.Buffer.from(input, offset, length);\n  } // Any version of node that supports the optional offset and length\n  // parameters, which were added in Node 6.0.0, will support Buffer.from and\n  // have already returned. Throw if offset is not 0 or if length differs from\n  // the underlying buffer's length.\n\n\n  if (offset !== 0 || length !== input.byteLength) {\n    throw new Error(\"Unable to convert TypedArray to Buffer in Node \" + process.version);\n  }\n\n  return new buffer_1.Buffer(input);\n}\n\nexports.fromArrayBuffer = fromArrayBuffer;\n\nfunction fromString(input, encoding) {\n  if (typeof input !== \"string\") {\n    throw new Error(\"argument passed to fromString was not a string\");\n  }\n\n  if (typeof buffer_1.Buffer.from === \"function\" && buffer_1.Buffer.from !== Uint8Array.from) {\n    return buffer_1.Buffer.from(input, encoding);\n  }\n\n  return new buffer_1.Buffer(input, encoding);\n}\n\nexports.fromString = fromString;","map":{"version":3,"sources":["index.ts"],"names":[],"mappings":";;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,IAAA,iBAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AAEA,SAAgB,eAAhB,CACE,KADF,EAEE,MAFF,EAGE,MAHF,EAG4C;AAD1C,MAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,MAAA,GAAA,CAAA;AAAkB;;AAClB,MAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,MAAA,GAAiB,KAAK,CAAC,UAAN,GAAmB,MAApC;AAA0C;;AAE1C,MAAI,CAAC,iBAAA,CAAA,aAAA,CAAc,KAAd,CAAL,EAA2B;AACzB,UAAM,IAAI,KAAJ,CACJ,2DADI,CAAN;AAGD;;AAED,MAAI,OAAO,QAAA,CAAA,MAAA,CAAO,IAAd,KAAuB,UAAvB,IAAqC,QAAA,CAAA,MAAA,CAAO,IAAP,KAAgB,UAAU,CAAC,IAApE,EAA0E;AACxE,WAAO,QAAA,CAAA,MAAA,CAAO,IAAP,CAAY,KAAZ,EAAmB,MAAnB,EAA2B,MAA3B,CAAP;AACD,GAVyC,CAY1C;AACA;AACA;AACA;;;AACA,MAAI,MAAM,KAAK,CAAX,IAAgB,MAAM,KAAK,KAAK,CAAC,UAArC,EAAiD;AAC/C,UAAM,IAAI,KAAJ,CACJ,oDAAkD,OAAO,CAAC,OADtD,CAAN;AAGD;;AACD,SAAO,IAAI,QAAA,CAAA,MAAJ,CAAW,KAAX,CAAP;AACD;;AAzBD,OAAA,CAAA,eAAA,GAAA,eAAA;;AA2BA,SAAgB,UAAhB,CACE,KADF,EAEE,QAFF,EAWY;AAEV,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAM,IAAI,KAAJ,CAAU,gDAAV,CAAN;AACD;;AAED,MAAI,OAAO,QAAA,CAAA,MAAA,CAAO,IAAd,KAAuB,UAAvB,IAAqC,QAAA,CAAA,MAAA,CAAO,IAAP,KAAgB,UAAU,CAAC,IAApE,EAA0E;AACxE,WAAO,QAAA,CAAA,MAAA,CAAO,IAAP,CAAY,KAAZ,EAAmB,QAAnB,CAAP;AACD;;AAED,SAAO,IAAI,QAAA,CAAA,MAAJ,CAAW,KAAX,EAAkB,QAAlB,CAAP;AACD;;AAtBD,OAAA,CAAA,UAAA,GAAA,UAAA","sourcesContent":["import { Buffer } from \"buffer\";\nimport { isArrayBuffer } from \"@aws-sdk/is-array-buffer\";\n\nexport function fromArrayBuffer(\n  input: ArrayBuffer,\n  offset: number = 0,\n  length: number = input.byteLength - offset\n): Buffer {\n  if (!isArrayBuffer(input)) {\n    throw new Error(\n      \"argument passed to fromArrayBuffer was not an ArrayBuffer\"\n    );\n  }\n\n  if (typeof Buffer.from === \"function\" && Buffer.from !== Uint8Array.from) {\n    return Buffer.from(input, offset, length);\n  }\n\n  // Any version of node that supports the optional offset and length\n  // parameters, which were added in Node 6.0.0, will support Buffer.from and\n  // have already returned. Throw if offset is not 0 or if length differs from\n  // the underlying buffer's length.\n  if (offset !== 0 || length !== input.byteLength) {\n    throw new Error(\n      `Unable to convert TypedArray to Buffer in Node ${process.version}`\n    );\n  }\n  return new Buffer(input);\n}\n\nexport function fromString(\n  input: string,\n  encoding?:\n    | \"ascii\"\n    | \"utf8\"\n    | \"utf16le\"\n    | \"ucs2\"\n    | \"base64\"\n    | \"latin1\"\n    | \"binary\"\n    | \"hex\"\n    | string\n): Buffer {\n  if (typeof input !== \"string\") {\n    throw new Error(\"argument passed to fromString was not a string\");\n  }\n\n  if (typeof Buffer.from === \"function\" && Buffer.from !== Uint8Array.from) {\n    return Buffer.from(input, encoding);\n  }\n\n  return new Buffer(input, encoding);\n}\n"],"sourceRoot":"./src/"},"metadata":{},"sourceType":"script"}