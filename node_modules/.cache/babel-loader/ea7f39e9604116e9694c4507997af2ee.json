{"ast":null,"code":"function createError(message) {\n  var err = new Error(message);\n  err.source = \"ulid\";\n  return err;\n} // These values should NEVER change. If\n// they do, we're no longer making ulids!\n\n\nvar ENCODING = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"; // Crockford's Base32\n\nvar ENCODING_LEN = ENCODING.length;\nvar TIME_MAX = Math.pow(2, 48) - 1;\nvar TIME_LEN = 10;\nvar RANDOM_LEN = 16;\n\nfunction replaceCharAt(str, index, char) {\n  if (index > str.length - 1) {\n    return str;\n  }\n\n  return str.substr(0, index) + char + str.substr(index + 1);\n}\n\nfunction incrementBase32(str) {\n  var done = undefined;\n  var index = str.length;\n  var char = void 0;\n  var charIndex = void 0;\n  var maxCharIndex = ENCODING_LEN - 1;\n\n  while (!done && index-- >= 0) {\n    char = str[index];\n    charIndex = ENCODING.indexOf(char);\n\n    if (charIndex === -1) {\n      throw createError(\"incorrectly encoded string\");\n    }\n\n    if (charIndex === maxCharIndex) {\n      str = replaceCharAt(str, index, ENCODING[0]);\n      continue;\n    }\n\n    done = replaceCharAt(str, index, ENCODING[charIndex + 1]);\n  }\n\n  if (typeof done === \"string\") {\n    return done;\n  }\n\n  throw createError(\"cannot increment this string\");\n}\n\nfunction randomChar(prng) {\n  var rand = Math.floor(prng() * ENCODING_LEN);\n\n  if (rand === ENCODING_LEN) {\n    rand = ENCODING_LEN - 1;\n  }\n\n  return ENCODING.charAt(rand);\n}\n\nfunction encodeTime(now, len) {\n  if (isNaN(now)) {\n    throw new Error(now + \" must be a number\");\n  }\n\n  if (now > TIME_MAX) {\n    throw createError(\"cannot encode time greater than \" + TIME_MAX);\n  }\n\n  if (now < 0) {\n    throw createError(\"time must be positive\");\n  }\n\n  if (Number.isInteger(now) === false) {\n    throw createError(\"time must be an integer\");\n  }\n\n  var mod = void 0;\n  var str = \"\";\n\n  for (; len > 0; len--) {\n    mod = now % ENCODING_LEN;\n    str = ENCODING.charAt(mod) + str;\n    now = (now - mod) / ENCODING_LEN;\n  }\n\n  return str;\n}\n\nfunction encodeRandom(len, prng) {\n  var str = \"\";\n\n  for (; len > 0; len--) {\n    str = randomChar(prng) + str;\n  }\n\n  return str;\n}\n\nfunction decodeTime(id) {\n  if (id.length !== TIME_LEN + RANDOM_LEN) {\n    throw createError(\"malformed ulid\");\n  }\n\n  var time = id.substr(0, TIME_LEN).split(\"\").reverse().reduce(function (carry, char, index) {\n    var encodingIndex = ENCODING.indexOf(char);\n\n    if (encodingIndex === -1) {\n      throw createError(\"invalid character found: \" + char);\n    }\n\n    return carry += encodingIndex * Math.pow(ENCODING_LEN, index);\n  }, 0);\n\n  if (time > TIME_MAX) {\n    throw createError(\"malformed ulid, timestamp too large\");\n  }\n\n  return time;\n}\n\nfunction detectPrng() {\n  var allowInsecure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var root = arguments[1];\n\n  if (!root) {\n    root = typeof window !== \"undefined\" ? window : null;\n  }\n\n  var browserCrypto = root && (root.crypto || root.msCrypto);\n\n  if (browserCrypto) {\n    return function () {\n      var buffer = new Uint8Array(1);\n      browserCrypto.getRandomValues(buffer);\n      return buffer[0] / 0xff;\n    };\n  } else {\n    try {\n      var nodeCrypto = require(\"crypto\");\n\n      return function () {\n        return nodeCrypto.randomBytes(1).readUInt8() / 0xff;\n      };\n    } catch (e) {}\n  }\n\n  if (allowInsecure) {\n    try {\n      console.error(\"secure crypto unusable, falling back to insecure Math.random()!\");\n    } catch (e) {}\n\n    return function () {\n      return Math.random();\n    };\n  }\n\n  throw createError(\"secure crypto unusable, insecure Math.random not allowed\");\n}\n\nfunction factory(currPrng) {\n  if (!currPrng) {\n    currPrng = detectPrng();\n  }\n\n  return function ulid(seedTime) {\n    if (isNaN(seedTime)) {\n      seedTime = Date.now();\n    }\n\n    return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);\n  };\n}\n\nfunction monotonicFactory(currPrng) {\n  if (!currPrng) {\n    currPrng = detectPrng();\n  }\n\n  var lastTime = 0;\n  var lastRandom = void 0;\n  return function ulid(seedTime) {\n    if (isNaN(seedTime)) {\n      seedTime = Date.now();\n    }\n\n    if (seedTime <= lastTime) {\n      var incrementedRandom = lastRandom = incrementBase32(lastRandom);\n      return encodeTime(lastTime, TIME_LEN) + incrementedRandom;\n    }\n\n    lastTime = seedTime;\n    var newRandom = lastRandom = encodeRandom(RANDOM_LEN, currPrng);\n    return encodeTime(seedTime, TIME_LEN) + newRandom;\n  };\n}\n\nvar ulid = factory();\nexport { replaceCharAt, incrementBase32, randomChar, encodeTime, encodeRandom, decodeTime, detectPrng, factory, monotonicFactory, ulid };","map":{"version":3,"sources":["C:/Users/Kaustubh Sinha/Desktop/bookkart/node_modules/ulid/dist/index.esm.js"],"names":["createError","message","err","Error","source","ENCODING","ENCODING_LEN","length","TIME_MAX","Math","pow","TIME_LEN","RANDOM_LEN","replaceCharAt","str","index","char","substr","incrementBase32","done","undefined","charIndex","maxCharIndex","indexOf","randomChar","prng","rand","floor","charAt","encodeTime","now","len","isNaN","Number","isInteger","mod","encodeRandom","decodeTime","id","time","split","reverse","reduce","carry","encodingIndex","detectPrng","allowInsecure","arguments","root","window","browserCrypto","crypto","msCrypto","buffer","Uint8Array","getRandomValues","nodeCrypto","require","randomBytes","readUInt8","e","console","error","random","factory","currPrng","ulid","seedTime","Date","monotonicFactory","lastTime","lastRandom","incrementedRandom","newRandom"],"mappings":"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","sourcesContent":["function createError(message) {\n    var err = new Error(message);\n    err.source = \"ulid\";\n    return err;\n}\n// These values should NEVER change. If\n// they do, we're no longer making ulids!\nvar ENCODING = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"; // Crockford's Base32\nvar ENCODING_LEN = ENCODING.length;\nvar TIME_MAX = Math.pow(2, 48) - 1;\nvar TIME_LEN = 10;\nvar RANDOM_LEN = 16;\nfunction replaceCharAt(str, index, char) {\n    if (index > str.length - 1) {\n        return str;\n    }\n    return str.substr(0, index) + char + str.substr(index + 1);\n}\nfunction incrementBase32(str) {\n    var done = undefined;\n    var index = str.length;\n    var char = void 0;\n    var charIndex = void 0;\n    var maxCharIndex = ENCODING_LEN - 1;\n    while (!done && index-- >= 0) {\n        char = str[index];\n        charIndex = ENCODING.indexOf(char);\n        if (charIndex === -1) {\n            throw createError(\"incorrectly encoded string\");\n        }\n        if (charIndex === maxCharIndex) {\n            str = replaceCharAt(str, index, ENCODING[0]);\n            continue;\n        }\n        done = replaceCharAt(str, index, ENCODING[charIndex + 1]);\n    }\n    if (typeof done === \"string\") {\n        return done;\n    }\n    throw createError(\"cannot increment this string\");\n}\nfunction randomChar(prng) {\n    var rand = Math.floor(prng() * ENCODING_LEN);\n    if (rand === ENCODING_LEN) {\n        rand = ENCODING_LEN - 1;\n    }\n    return ENCODING.charAt(rand);\n}\nfunction encodeTime(now, len) {\n    if (isNaN(now)) {\n        throw new Error(now + \" must be a number\");\n    }\n    if (now > TIME_MAX) {\n        throw createError(\"cannot encode time greater than \" + TIME_MAX);\n    }\n    if (now < 0) {\n        throw createError(\"time must be positive\");\n    }\n    if (Number.isInteger(now) === false) {\n        throw createError(\"time must be an integer\");\n    }\n    var mod = void 0;\n    var str = \"\";\n    for (; len > 0; len--) {\n        mod = now % ENCODING_LEN;\n        str = ENCODING.charAt(mod) + str;\n        now = (now - mod) / ENCODING_LEN;\n    }\n    return str;\n}\nfunction encodeRandom(len, prng) {\n    var str = \"\";\n    for (; len > 0; len--) {\n        str = randomChar(prng) + str;\n    }\n    return str;\n}\nfunction decodeTime(id) {\n    if (id.length !== TIME_LEN + RANDOM_LEN) {\n        throw createError(\"malformed ulid\");\n    }\n    var time = id.substr(0, TIME_LEN).split(\"\").reverse().reduce(function (carry, char, index) {\n        var encodingIndex = ENCODING.indexOf(char);\n        if (encodingIndex === -1) {\n            throw createError(\"invalid character found: \" + char);\n        }\n        return carry += encodingIndex * Math.pow(ENCODING_LEN, index);\n    }, 0);\n    if (time > TIME_MAX) {\n        throw createError(\"malformed ulid, timestamp too large\");\n    }\n    return time;\n}\nfunction detectPrng() {\n    var allowInsecure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var root = arguments[1];\n\n    if (!root) {\n        root = typeof window !== \"undefined\" ? window : null;\n    }\n    var browserCrypto = root && (root.crypto || root.msCrypto);\n    if (browserCrypto) {\n        return function () {\n            var buffer = new Uint8Array(1);\n            browserCrypto.getRandomValues(buffer);\n            return buffer[0] / 0xff;\n        };\n    } else {\n        try {\n            var nodeCrypto = require(\"crypto\");\n            return function () {\n                return nodeCrypto.randomBytes(1).readUInt8() / 0xff;\n            };\n        } catch (e) {}\n    }\n    if (allowInsecure) {\n        try {\n            console.error(\"secure crypto unusable, falling back to insecure Math.random()!\");\n        } catch (e) {}\n        return function () {\n            return Math.random();\n        };\n    }\n    throw createError(\"secure crypto unusable, insecure Math.random not allowed\");\n}\nfunction factory(currPrng) {\n    if (!currPrng) {\n        currPrng = detectPrng();\n    }\n    return function ulid(seedTime) {\n        if (isNaN(seedTime)) {\n            seedTime = Date.now();\n        }\n        return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);\n    };\n}\nfunction monotonicFactory(currPrng) {\n    if (!currPrng) {\n        currPrng = detectPrng();\n    }\n    var lastTime = 0;\n    var lastRandom = void 0;\n    return function ulid(seedTime) {\n        if (isNaN(seedTime)) {\n            seedTime = Date.now();\n        }\n        if (seedTime <= lastTime) {\n            var incrementedRandom = lastRandom = incrementBase32(lastRandom);\n            return encodeTime(lastTime, TIME_LEN) + incrementedRandom;\n        }\n        lastTime = seedTime;\n        var newRandom = lastRandom = encodeRandom(RANDOM_LEN, currPrng);\n        return encodeTime(seedTime, TIME_LEN) + newRandom;\n    };\n}\nvar ulid = factory();\n\nexport { replaceCharAt, incrementBase32, randomChar, encodeTime, encodeRandom, decodeTime, detectPrng, factory, monotonicFactory, ulid };\n"]},"metadata":{},"sourceType":"module"}