{"ast":null,"code":"'use strict';\n\nconst util = require('./util');\n\nconst buildOptions = require('./util').buildOptions;\n\nconst xmlNode = require('./xmlNode');\n\nconst regx = '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'.replace(/NAME/g, util.nameRegexp); //const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n//polyfill\n\nif (!Number.parseInt && window.parseInt) {\n  Number.parseInt = window.parseInt;\n}\n\nif (!Number.parseFloat && window.parseFloat) {\n  Number.parseFloat = window.parseFloat;\n}\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  ignoreNameSpace: false,\n  allowBooleanAttributes: false,\n  //a tag can have attributes without any value\n  //ignoreRootElement : false,\n  parseNodeValue: true,\n  parseAttributeValue: false,\n  arrayMode: false,\n  trimValues: true,\n  //Trim string values of tag and attributes\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  tagValueProcessor: function (a, tagName) {\n    return a;\n  },\n  attrValueProcessor: function (a, attrName) {\n    return a;\n  },\n  stopNodes: [] //decodeStrict: false,\n\n};\nexports.defaultOptions = defaultOptions;\nconst props = ['attributeNamePrefix', 'attrNodeName', 'textNodeName', 'ignoreAttributes', 'ignoreNameSpace', 'allowBooleanAttributes', 'parseNodeValue', 'parseAttributeValue', 'arrayMode', 'trimValues', 'cdataTagName', 'cdataPositionChar', 'tagValueProcessor', 'attrValueProcessor', 'parseTrueNumberOnly', 'stopNodes'];\nexports.props = props;\n/**\n * Trim -> valueProcessor -> parse value\n * @param {string} tagName\n * @param {string} val\n * @param {object} options\n */\n\nfunction processTagValue(tagName, val, options) {\n  if (val) {\n    if (options.trimValues) {\n      val = val.trim();\n    }\n\n    val = options.tagValueProcessor(val, tagName);\n    val = parseValue(val, options.parseNodeValue, options.parseTrueNumberOnly);\n  }\n\n  return val;\n}\n\nfunction resolveNameSpace(tagname, options) {\n  if (options.ignoreNameSpace) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n\n  return tagname;\n}\n\nfunction parseValue(val, shouldParse, parseTrueNumberOnly) {\n  if (shouldParse && typeof val === 'string') {\n    let parsed;\n\n    if (val.trim() === '' || isNaN(val)) {\n      parsed = val === 'true' ? true : val === 'false' ? false : val;\n    } else {\n      if (val.indexOf('0x') !== -1) {\n        //support hexa decimal\n        parsed = Number.parseInt(val, 16);\n      } else if (val.indexOf('.') !== -1) {\n        parsed = Number.parseFloat(val);\n        val = val.replace(/\\.?0+$/, \"\");\n      } else {\n        parsed = Number.parseInt(val, 10);\n      }\n\n      if (parseTrueNumberOnly) {\n        parsed = String(parsed) === val ? parsed : val;\n      }\n    }\n\n    return parsed;\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n} //TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\n\n\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])(.*?)\\\\3)?', 'g');\n\nfunction buildAttributesMap(attrStr, options) {\n  if (!options.ignoreAttributes && typeof attrStr === 'string') {\n    attrStr = attrStr.replace(/\\r?\\n/g, ' '); //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n\n    const attrs = {};\n\n    for (let i = 0; i < len; i++) {\n      const attrName = resolveNameSpace(matches[i][1], options);\n\n      if (attrName.length) {\n        if (matches[i][4] !== undefined) {\n          if (options.trimValues) {\n            matches[i][4] = matches[i][4].trim();\n          }\n\n          matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);\n          attrs[options.attributeNamePrefix + attrName] = parseValue(matches[i][4], options.parseAttributeValue, options.parseTrueNumberOnly);\n        } else if (options.allowBooleanAttributes) {\n          attrs[options.attributeNamePrefix + attrName] = true;\n        }\n      }\n    }\n\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n\n    if (options.attrNodeName) {\n      const attrCollection = {};\n      attrCollection[options.attrNodeName] = attrs;\n      return attrCollection;\n    }\n\n    return attrs;\n  }\n}\n\nconst getTraversalObj = function (xmlData, options) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\");\n  options = buildOptions(options, defaultOptions, props);\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\"; //function match(xmlData){\n\n  for (let i = 0; i < xmlData.length; i++) {\n    const ch = xmlData[i];\n\n    if (ch === '<') {\n      if (xmlData[i + 1] === '/') {\n        //Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\");\n        let tagName = xmlData.substring(i + 2, closeIndex).trim();\n\n        if (options.ignoreNameSpace) {\n          const colonIndex = tagName.indexOf(\":\");\n\n          if (colonIndex !== -1) {\n            tagName = tagName.substr(colonIndex + 1);\n          }\n        }\n        /* if (currentNode.parent) {\n          currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue2(tagName, textData , options);\n        } */\n\n\n        if (currentNode) {\n          if (currentNode.val) {\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tagName, textData, options);\n          } else {\n            currentNode.val = processTagValue(tagName, textData, options);\n          }\n        }\n\n        if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {\n          currentNode.child = [];\n\n          if (currentNode.attrsMap == undefined) {\n            currentNode.attrsMap = {};\n          }\n\n          currentNode.val = xmlData.substr(currentNode.startIndex + 1, i - currentNode.startIndex - 1);\n        }\n\n        currentNode = currentNode.parent;\n        textData = \"\";\n        i = closeIndex;\n      } else if (xmlData[i + 1] === '?') {\n        i = findClosingIndex(xmlData, \"?>\", i, \"Pi Tag is not closed.\");\n      } else if (xmlData.substr(i + 1, 3) === '!--') {\n        i = findClosingIndex(xmlData, \"-->\", i, \"Comment is not closed.\");\n      } else if (xmlData.substr(i + 1, 2) === '!D') {\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"DOCTYPE is not closed.\");\n        const tagExp = xmlData.substring(i, closeIndex);\n\n        if (tagExp.indexOf(\"[\") >= 0) {\n          i = xmlData.indexOf(\"]>\", i) + 1;\n        } else {\n          i = closeIndex;\n        }\n      } else if (xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9, closeIndex); //considerations\n        //1. CDATA will always have parent node\n        //2. A tag with CDATA is not a leaf node so it's value would be string type.\n\n        if (textData) {\n          currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData, options);\n          textData = \"\";\n        }\n\n        if (options.cdataTagName) {\n          //add cdata node\n          const childNode = new xmlNode(options.cdataTagName, currentNode, tagExp);\n          currentNode.addChild(childNode); //for backtracking\n\n          currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar; //add rest value to parent node\n\n          if (tagExp) {\n            childNode.val = tagExp;\n          }\n        } else {\n          currentNode.val = (currentNode.val || '') + (tagExp || '');\n        }\n\n        i = closeIndex + 2;\n      } else {\n        //Opening tag\n        const result = closingIndexForOpeningTag(xmlData, i + 1);\n        let tagExp = result.data;\n        const closeIndex = result.index;\n        const separatorIndex = tagExp.indexOf(\" \");\n        let tagName = tagExp;\n        let shouldBuildAttributesMap = true;\n\n        if (separatorIndex !== -1) {\n          tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n          tagExp = tagExp.substr(separatorIndex + 1);\n        }\n\n        if (options.ignoreNameSpace) {\n          const colonIndex = tagName.indexOf(\":\");\n\n          if (colonIndex !== -1) {\n            tagName = tagName.substr(colonIndex + 1);\n            shouldBuildAttributesMap = tagName !== result.data.substr(colonIndex + 1);\n          }\n        } //save text to parent node\n\n\n        if (currentNode && textData) {\n          if (currentNode.tagname !== '!xml') {\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData, options);\n          }\n        }\n\n        if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n          //selfClosing tag\n          if (tagName[tagName.length - 1] === \"/\") {\n            //remove trailing '/'\n            tagName = tagName.substr(0, tagName.length - 1);\n            tagExp = tagName;\n          } else {\n            tagExp = tagExp.substr(0, tagExp.length - 1);\n          }\n\n          const childNode = new xmlNode(tagName, currentNode, '');\n\n          if (tagName !== tagExp) {\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n\n          currentNode.addChild(childNode);\n        } else {\n          //opening tag\n          const childNode = new xmlNode(tagName, currentNode);\n\n          if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {\n            childNode.startIndex = closeIndex;\n          }\n\n          if (tagName !== tagExp && shouldBuildAttributesMap) {\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n\n          currentNode.addChild(childNode);\n          currentNode = childNode;\n        }\n\n        textData = \"\";\n        i = closeIndex;\n      }\n    } else {\n      textData += xmlData[i];\n    }\n  }\n\n  return xmlObj;\n};\n\nfunction closingIndexForOpeningTag(data, i) {\n  let attrBoundary;\n  let tagExp = \"\";\n\n  for (let index = i; index < data.length; index++) {\n    let ch = data[index];\n\n    if (attrBoundary) {\n      if (ch === attrBoundary) attrBoundary = \"\"; //reset\n    } else if (ch === '\"' || ch === \"'\") {\n      attrBoundary = ch;\n    } else if (ch === '>') {\n      return {\n        data: tagExp,\n        index: index\n      };\n    } else if (ch === '\\t') {\n      ch = \" \";\n    }\n\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg) {\n  const closingIndex = xmlData.indexOf(str, i);\n\n  if (closingIndex === -1) {\n    throw new Error(errMsg);\n  } else {\n    return closingIndex + str.length - 1;\n  }\n}\n\nexports.getTraversalObj = getTraversalObj;","map":{"version":3,"sources":["C:/Users/Kaustubh Sinha/Desktop/bookkart/node_modules/fast-xml-parser/src/xmlstr2xmlnode.js"],"names":["util","require","buildOptions","xmlNode","regx","replace","nameRegexp","Number","parseInt","window","parseFloat","defaultOptions","attributeNamePrefix","attrNodeName","textNodeName","ignoreAttributes","ignoreNameSpace","allowBooleanAttributes","parseNodeValue","parseAttributeValue","arrayMode","trimValues","cdataTagName","cdataPositionChar","tagValueProcessor","a","tagName","attrValueProcessor","attrName","stopNodes","exports","props","processTagValue","val","options","trim","parseValue","parseTrueNumberOnly","resolveNameSpace","tagname","tags","split","prefix","charAt","length","shouldParse","parsed","isNaN","indexOf","String","isExist","attrsRegx","RegExp","buildAttributesMap","attrStr","matches","getAllMatches","len","attrs","i","undefined","Object","keys","attrCollection","getTraversalObj","xmlData","xmlObj","currentNode","textData","ch","closeIndex","findClosingIndex","substring","colonIndex","substr","getValue","includes","child","attrsMap","startIndex","parent","tagExp","childNode","addChild","result","closingIndexForOpeningTag","data","index","separatorIndex","shouldBuildAttributesMap","lastIndexOf","attrBoundary","str","errMsg","closingIndex","Error"],"mappings":"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","sourcesContent":["'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst xmlNode = require('./xmlNode');\nconst regx =\n  '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n  .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n  Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n  Number.parseFloat = window.parseFloat;\n}\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  ignoreNameSpace: false,\n  allowBooleanAttributes: false, //a tag can have attributes without any value\n  //ignoreRootElement : false,\n  parseNodeValue: true,\n  parseAttributeValue: false,\n  arrayMode: false,\n  trimValues: true, //Trim string values of tag and attributes\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  tagValueProcessor: function(a, tagName) {\n    return a;\n  },\n  attrValueProcessor: function(a, attrName) {\n    return a;\n  },\n  stopNodes: []\n  //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\n\nconst props = [\n  'attributeNamePrefix',\n  'attrNodeName',\n  'textNodeName',\n  'ignoreAttributes',\n  'ignoreNameSpace',\n  'allowBooleanAttributes',\n  'parseNodeValue',\n  'parseAttributeValue',\n  'arrayMode',\n  'trimValues',\n  'cdataTagName',\n  'cdataPositionChar',\n  'tagValueProcessor',\n  'attrValueProcessor',\n  'parseTrueNumberOnly',\n  'stopNodes'\n];\nexports.props = props;\n\n/**\n * Trim -> valueProcessor -> parse value\n * @param {string} tagName\n * @param {string} val\n * @param {object} options\n */\nfunction processTagValue(tagName, val, options) {\n  if (val) {\n    if (options.trimValues) {\n      val = val.trim();\n    }\n    val = options.tagValueProcessor(val, tagName);\n    val = parseValue(val, options.parseNodeValue, options.parseTrueNumberOnly);\n  }\n\n  return val;\n}\n\nfunction resolveNameSpace(tagname, options) {\n  if (options.ignoreNameSpace) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\nfunction parseValue(val, shouldParse, parseTrueNumberOnly) {\n  if (shouldParse && typeof val === 'string') {\n    let parsed;\n    if (val.trim() === '' || isNaN(val)) {\n      parsed = val === 'true' ? true : val === 'false' ? false : val;\n    } else {\n      if (val.indexOf('0x') !== -1) {\n        //support hexa decimal\n        parsed = Number.parseInt(val, 16);\n      } else if (val.indexOf('.') !== -1) {\n        parsed = Number.parseFloat(val);\n        val = val.replace(/\\.?0+$/, \"\");\n      } else {\n        parsed = Number.parseInt(val, 10);\n      }\n      if (parseTrueNumberOnly) {\n        parsed = String(parsed) === val ? parsed : val;\n      }\n    }\n    return parsed;\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])(.*?)\\\\3)?', 'g');\n\nfunction buildAttributesMap(attrStr, options) {\n  if (!options.ignoreAttributes && typeof attrStr === 'string') {\n    attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = resolveNameSpace(matches[i][1], options);\n      if (attrName.length) {\n        if (matches[i][4] !== undefined) {\n          if (options.trimValues) {\n            matches[i][4] = matches[i][4].trim();\n          }\n          matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);\n          attrs[options.attributeNamePrefix + attrName] = parseValue(\n            matches[i][4],\n            options.parseAttributeValue,\n            options.parseTrueNumberOnly\n          );\n        } else if (options.allowBooleanAttributes) {\n          attrs[options.attributeNamePrefix + attrName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (options.attrNodeName) {\n      const attrCollection = {};\n      attrCollection[options.attrNodeName] = attrs;\n      return attrCollection;\n    }\n    return attrs;\n  }\n}\n\nconst getTraversalObj = function(xmlData, options) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\");\n  options = buildOptions(options, defaultOptions, props);\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n\n//function match(xmlData){\n  for(let i=0; i< xmlData.length; i++){\n    const ch = xmlData[i];\n    if(ch === '<'){\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(options.ignoreNameSpace){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        /* if (currentNode.parent) {\n          currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue2(tagName, textData , options);\n        } */\n        if(currentNode){\n          if(currentNode.val){\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tagName, textData , options);\n          }else{\n            currentNode.val = processTagValue(tagName, textData , options);\n          }\n        }\n\n        if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {\n          currentNode.child = []\n          if (currentNode.attrsMap == undefined) { currentNode.attrsMap = {}}\n          currentNode.val = xmlData.substr(currentNode.startIndex + 1, i - currentNode.startIndex - 1)\n        }\n        currentNode = currentNode.parent;\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n        i = findClosingIndex(xmlData, \"?>\", i, \"Pi Tag is not closed.\")\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        i = findClosingIndex(xmlData, \"-->\", i, \"Comment is not closed.\")\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"DOCTYPE is not closed.\")\n        const tagExp = xmlData.substring(i, closeIndex);\n        if(tagExp.indexOf(\"[\") >= 0){\n          i = xmlData.indexOf(\"]>\", i) + 1;\n        }else{\n          i = closeIndex;\n        }\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        //considerations\n        //1. CDATA will always have parent node\n        //2. A tag with CDATA is not a leaf node so it's value would be string type.\n        if(textData){\n          currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData , options);\n          textData = \"\";\n        }\n\n        if (options.cdataTagName) {\n          //add cdata node\n          const childNode = new xmlNode(options.cdataTagName, currentNode, tagExp);\n          currentNode.addChild(childNode);\n          //for backtracking\n          currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n          //add rest value to parent node\n          if (tagExp) {\n            childNode.val = tagExp;\n          }\n        } else {\n          currentNode.val = (currentNode.val || '') + (tagExp || '');\n        }\n\n        i = closeIndex + 2;\n      }else {//Opening tag\n        const result = closingIndexForOpeningTag(xmlData, i+1)\n        let tagExp = result.data;\n        const closeIndex = result.index;\n        const separatorIndex = tagExp.indexOf(\" \");\n        let tagName = tagExp;\n        let shouldBuildAttributesMap = true;\n        if(separatorIndex !== -1){\n          tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n          tagExp = tagExp.substr(separatorIndex + 1);\n        }\n\n        if(options.ignoreNameSpace){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n            shouldBuildAttributesMap = tagName !== result.data.substr(colonIndex + 1);\n          }\n        }\n\n        //save text to parent node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue( currentNode.tagname, textData, options);\n          }\n        }\n\n        if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){//selfClosing tag\n\n          if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n            tagName = tagName.substr(0, tagName.length - 1);\n            tagExp = tagName;\n          }else{\n            tagExp = tagExp.substr(0, tagExp.length - 1);\n          }\n\n          const childNode = new xmlNode(tagName, currentNode, '');\n          if(tagName !== tagExp){\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n        }else{//opening tag\n\n          const childNode = new xmlNode( tagName, currentNode );\n          if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {\n            childNode.startIndex=closeIndex;\n          }\n          if(tagName !== tagExp && shouldBuildAttributesMap){\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n          currentNode = childNode;\n        }\n        textData = \"\";\n        i = closeIndex;\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj;\n}\n\nfunction closingIndexForOpeningTag(data, i){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < data.length; index++) {\n    let ch = data[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === '>') {\n        return {\n          data: tagExp,\n          index: index\n        }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nexports.getTraversalObj = getTraversalObj;\n"]},"metadata":{},"sourceType":"script"}