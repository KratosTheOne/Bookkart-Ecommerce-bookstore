{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction getChunkedStream(source) {\n  var sourceReader = source.getReader();\n  var currentMessageTotalLength = 0;\n  var currentMessagePendingLength = 0;\n  var currentMessage = null;\n  var messageLengthBuffer = null;\n\n  var allocateMessage = function (size) {\n    if (typeof size !== \"number\") {\n      throw new Error(\"Attempted to allocate an event message where size was not a number: \" + size);\n    }\n\n    currentMessageTotalLength = size;\n    currentMessagePendingLength = 4;\n    currentMessage = new Uint8Array(size);\n    var currentMessageView = new DataView(currentMessage.buffer);\n    currentMessageView.setUint32(0, size, false); //set big-endian Uint32 to 0~3 bytes\n  };\n\n  var chunkedStream = new ReadableStream({\n    start: function (controller) {\n      function push() {\n        return sourceReader.read().then(function (_a) {\n          var done = _a.done,\n              value = _a.value;\n\n          if (done) {\n            if (currentMessageTotalLength) {\n              if (currentMessageTotalLength === currentMessagePendingLength) {\n                controller.enqueue(currentMessage);\n              } else {\n                throw new Error(\"Truncated event message received.\");\n              }\n            }\n\n            controller.close();\n            return;\n          } // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n\n\n          var chunkLength = value.length;\n          var currentOffset = 0;\n\n          while (currentOffset < chunkLength) {\n            // create new message if necessary\n            if (!currentMessage) {\n              // working on a new message, determine total length\n              var bytesRemaining = chunkLength - currentOffset; // prevent edge case where total length spans 2 chunks\n\n              if (!messageLengthBuffer) {\n                messageLengthBuffer = new Uint8Array(4);\n              }\n\n              var numBytesForTotal = Math.min(4 - currentMessagePendingLength, // remaining bytes to fill the messageLengthBuffer\n              bytesRemaining // bytes left in chunk\n              );\n              messageLengthBuffer.set( // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n              value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);\n              currentMessagePendingLength += numBytesForTotal;\n              currentOffset += numBytesForTotal;\n\n              if (currentMessagePendingLength < 4) {\n                // not enough information to create the current message\n                break;\n              }\n\n              allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));\n              messageLengthBuffer = null;\n            } // write data into current message\n\n\n            var numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, // number of bytes left to complete message\n            chunkLength - currentOffset // number of bytes left in the original chunk\n            );\n            currentMessage.set( // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n            value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);\n            currentMessagePendingLength += numBytesToWrite;\n            currentOffset += numBytesToWrite; // check if a message is ready to be pushed\n\n            if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {\n              // push out the message\n              controller.enqueue(currentMessage); // cleanup\n\n              currentMessage = null;\n              currentMessageTotalLength = 0;\n              currentMessagePendingLength = 0;\n            }\n          }\n\n          push();\n        });\n      }\n\n      push();\n    }\n  });\n  return chunkedStream;\n}\n\nexports.getChunkedStream = getChunkedStream;","map":{"version":3,"sources":["../src/getChunkedStream.ts"],"names":[],"mappings":"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","sourcesContent":["export function getChunkedStream(\n  source: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  const sourceReader = source.getReader();\n  let currentMessageTotalLength = 0;\n  let currentMessagePendingLength = 0;\n  let currentMessage: Uint8Array | null = null;\n  let messageLengthBuffer: Uint8Array | null = null;\n  const allocateMessage = function (size: number) {\n    if (typeof size !== \"number\") {\n      throw new Error(\n        \"Attempted to allocate an event message where size was not a number: \" +\n          size\n      );\n    }\n    currentMessageTotalLength = size;\n    currentMessagePendingLength = 4;\n    currentMessage = new Uint8Array(size);\n    const currentMessageView = new DataView(currentMessage.buffer);\n    currentMessageView.setUint32(0, size, false); //set big-endian Uint32 to 0~3 bytes\n  };\n\n  const chunkedStream = new ReadableStream({\n    start(controller) {\n      function push() {\n        return sourceReader.read().then(({ done, value }) => {\n          if (done) {\n            if (currentMessageTotalLength) {\n              if (currentMessageTotalLength === currentMessagePendingLength) {\n                controller.enqueue(currentMessage);\n              } else {\n                throw new Error(\"Truncated event message received.\");\n              }\n            }\n            controller.close();\n            return;\n          }\n\n          // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n          const chunkLength = value.length;\n          let currentOffset = 0;\n\n          while (currentOffset < chunkLength) {\n            // create new message if necessary\n            if (!currentMessage) {\n              // working on a new message, determine total length\n              const bytesRemaining = chunkLength - currentOffset;\n              // prevent edge case where total length spans 2 chunks\n              if (!messageLengthBuffer) {\n                messageLengthBuffer = new Uint8Array(4);\n              }\n              const numBytesForTotal = Math.min(\n                4 - currentMessagePendingLength, // remaining bytes to fill the messageLengthBuffer\n                bytesRemaining // bytes left in chunk\n              );\n\n              messageLengthBuffer.set(\n                // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n                value.slice(currentOffset, currentOffset + numBytesForTotal),\n                currentMessagePendingLength\n              );\n\n              currentMessagePendingLength += numBytesForTotal;\n              currentOffset += numBytesForTotal;\n\n              if (currentMessagePendingLength < 4) {\n                // not enough information to create the current message\n                break;\n              }\n              allocateMessage(\n                new DataView(messageLengthBuffer.buffer).getUint32(0, false)\n              );\n              messageLengthBuffer = null;\n            }\n\n            // write data into current message\n            const numBytesToWrite = Math.min(\n              currentMessageTotalLength - currentMessagePendingLength, // number of bytes left to complete message\n              chunkLength - currentOffset // number of bytes left in the original chunk\n            );\n            currentMessage!.set(\n              // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n              value.slice(currentOffset, currentOffset + numBytesToWrite),\n              currentMessagePendingLength\n            );\n            currentMessagePendingLength += numBytesToWrite;\n            currentOffset += numBytesToWrite;\n\n            // check if a message is ready to be pushed\n            if (\n              currentMessageTotalLength &&\n              currentMessageTotalLength === currentMessagePendingLength\n            ) {\n              // push out the message\n              controller.enqueue(currentMessage);\n              // cleanup\n              currentMessage = null;\n              currentMessageTotalLength = 0;\n              currentMessagePendingLength = 0;\n            }\n          }\n          push();\n        });\n      }\n\n      push();\n    }\n  });\n\n  return chunkedStream;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}