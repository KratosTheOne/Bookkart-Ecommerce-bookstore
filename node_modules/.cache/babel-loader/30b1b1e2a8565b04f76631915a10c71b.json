{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar signature_v4_1 = require(\"@aws-sdk/signature-v4\");\n\nvar constants_1 = require(\"./constants\");\n\nvar S3RequestPresigner =\n/** @class */\nfunction () {\n  function S3RequestPresigner(options) {\n    var resolvedOptions = tslib_1.__assign({\n      // Allow `signingName` because we want to support usecase of supply client's resolved config\n      // directly. Where service equals signingName.\n      service: options.signingName || options.service || \"s3\",\n      uriEscapePath: options.uriEscapePath || false\n    }, options);\n\n    this.signer = new signature_v4_1.SignatureV4(resolvedOptions);\n  }\n\n  S3RequestPresigner.prototype.presign = function (requestToSign, _a) {\n    if (_a === void 0) {\n      _a = {};\n    }\n\n    var _b = _a.unsignableHeaders,\n        unsignableHeaders = _b === void 0 ? new Set() : _b,\n        options = tslib_1.__rest(_a, [\"unsignableHeaders\"]);\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_c) {\n        unsignableHeaders.add(\"content-type\");\n        requestToSign.headers[constants_1.SHA256_HEADER] = constants_1.UNSIGNED_PAYLOAD;\n        return [2\n        /*return*/\n        , this.signer.presign(requestToSign, tslib_1.__assign({\n          expiresIn: 900,\n          unsignableHeaders: unsignableHeaders\n        }, options))];\n      });\n    });\n  };\n\n  return S3RequestPresigner;\n}();\n\nexports.S3RequestPresigner = S3RequestPresigner;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;AACA,IAAA,cAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AAMA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAcA,IAAA,kBAAA;AAAA;AAAA,YAAA;AAEE,WAAA,kBAAA,CAAY,OAAZ,EAA8C;AAC5C,QAAM,eAAe,GAAA,OAAA,CAAA,QAAA,CAAA;AACnB;AACA;AACA,MAAA,OAAO,EAAE,OAAO,CAAC,WAAR,IAAuB,OAAO,CAAC,OAA/B,IAA0C,IAHhC;AAInB,MAAA,aAAa,EAAE,OAAO,CAAC,aAAR,IAAyB;AAJrB,KAAA,EAKhB,OALgB,CAArB;;AAOA,SAAK,MAAL,GAAc,IAAI,cAAA,CAAA,WAAJ,CAAgB,eAAhB,CAAd;AACD;;AAEY,EAAA,kBAAA,CAAA,SAAA,CAAA,OAAA,GAAb,UACE,aADF,EAEE,EAFF,EAKoC;AAHlC,QAAA,EAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,EAAA,GAAA,EAAA;AAGkC;;AAFhC,QAAA,EAAA,GAAA,EAAA,CAAA,iBAAA;AAAA,QAAA,iBAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,IAAA,GAAA,EAAA,GAAA,EAAA;AAAA,QACA,OAAA,GAAA,OAAA,CAAA,MAAA,CAAA,EAAA,EAAA,CAAA,mBAAA,CAAA,CADA;;;;AAIF,QAAA,iBAAiB,CAAC,GAAlB,CAAsB,cAAtB;AACA,QAAA,aAAa,CAAC,OAAd,CAAsB,WAAA,CAAA,aAAtB,IAAuC,WAAA,CAAA,gBAAvC;AACA,eAAA,CAAA;AAAA;AAAA,UAAO,KAAK,MAAL,CAAY,OAAZ,CAAoB,aAApB,EAAiC,OAAA,CAAA,QAAA,CAAA;AACtC,UAAA,SAAS,EAAE,GAD2B;AAEtC,UAAA,iBAAiB,EAAA;AAFqB,SAAA,EAGnC,OAHmC,CAAjC,CAAP,CAAA;;;AAKD,GAdY;;AAef,SAAA,kBAAA;AAAC,CA5BD,EAAA;;AAAa,OAAA,CAAA,kBAAA,GAAA,kBAAA","sourcesContent":["import { RequestPresigner, RequestPresigningArguments } from \"@aws-sdk/types\";\nimport {\n  SignatureV4,\n  SignatureV4Init,\n  SignatureV4CryptoInit\n} from \"@aws-sdk/signature-v4\";\nimport { HttpRequest as IHttpRequest } from \"@aws-sdk/types\";\nimport { UNSIGNED_PAYLOAD, SHA256_HEADER } from \"./constants\";\n\n/**\n * PartialBy<T, K> makes properties specified in K optional in interface T\n * see: https://stackoverflow.com/questions/43159887/make-a-single-property-optional-in-typescript\n * */\ntype Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\ntype PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport type S3RequestPresignerOptions = PartialBy<\n  SignatureV4Init & SignatureV4CryptoInit,\n  \"service\" | \"uriEscapePath\"\n> & { signingName?: string };\n\nexport class S3RequestPresigner implements RequestPresigner {\n  private readonly signer: SignatureV4;\n  constructor(options: S3RequestPresignerOptions) {\n    const resolvedOptions = {\n      // Allow `signingName` because we want to support usecase of supply client's resolved config\n      // directly. Where service equals signingName.\n      service: options.signingName || options.service || \"s3\",\n      uriEscapePath: options.uriEscapePath || false,\n      ...options\n    };\n    this.signer = new SignatureV4(resolvedOptions);\n  }\n\n  public async presign(\n    requestToSign: IHttpRequest,\n    {\n      unsignableHeaders = new Set(),\n      ...options\n    }: RequestPresigningArguments = {}\n  ): Promise<IHttpRequest> {\n    unsignableHeaders.add(\"content-type\");\n    requestToSign.headers[SHA256_HEADER] = UNSIGNED_PAYLOAD;\n    return this.signer.presign(requestToSign, {\n      expiresIn: 900,\n      unsignableHeaders,\n      ...options\n    });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}