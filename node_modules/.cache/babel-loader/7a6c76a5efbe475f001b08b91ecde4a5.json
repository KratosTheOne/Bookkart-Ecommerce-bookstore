{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar signature_v4_1 = require(\"@aws-sdk/signature-v4\");\n\nfunction resolveAwsAuthConfig(input) {\n  var _this = this;\n\n  var credentials = input.credentials || input.credentialDefaultProvider(input);\n  var normalizedCreds = normalizeProvider(credentials);\n  var _a = input.signingEscapePath,\n      signingEscapePath = _a === void 0 ? true : _a,\n      _b = input.systemClockOffset,\n      systemClockOffset = _b === void 0 ? input.systemClockOffset || 0 : _b,\n      sha256 = input.sha256;\n  var signer;\n\n  if (input.signer) {\n    //if signer is supplied by user, normalize it to a function returning a promise for signer.\n    signer = normalizeProvider(input.signer);\n  } else {\n    //construct a provider inferring signing from region.\n    signer = function () {\n      return normalizeProvider(input.region)().then(function (region) {\n        return tslib_1.__awaiter(_this, void 0, void 0, function () {\n          return tslib_1.__generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                return [4\n                /*yield*/\n                , input.regionInfoProvider(region)];\n\n              case 1:\n                return [2\n                /*return*/\n                , [_a.sent() || {}, region]];\n            }\n          });\n        });\n      }).then(function (_a) {\n        var _b = tslib_1.__read(_a, 2),\n            regionInfo = _b[0],\n            region = _b[1];\n\n        var _c = regionInfo.signingRegion,\n            signingRegion = _c === void 0 ? input.signingRegion : _c,\n            _d = regionInfo.signingService,\n            signingService = _d === void 0 ? input.signingName : _d; //update client's singing region and signing service config if they are resolved.\n        //signing region resolving order: user supplied signingRegion -> endpoints.json inferred region -> client region\n\n        input.signingRegion = input.signingRegion || signingRegion || region;\n        input.signingName = input.signingName || signingService;\n        return new signature_v4_1.SignatureV4({\n          credentials: normalizedCreds,\n          region: input.signingRegion,\n          service: input.signingName,\n          sha256: sha256,\n          uriEscapePath: signingEscapePath\n        });\n      });\n    };\n  }\n\n  return tslib_1.__assign(tslib_1.__assign({}, input), {\n    systemClockOffset: systemClockOffset,\n    signingEscapePath: signingEscapePath,\n    credentials: normalizedCreds,\n    signer: signer\n  });\n}\n\nexports.resolveAwsAuthConfig = resolveAwsAuthConfig;\n\nfunction normalizeProvider(input) {\n  if (typeof input === \"object\") {\n    var promisified_1 = Promise.resolve(input);\n    return function () {\n      return promisified_1;\n    };\n  }\n\n  return input;\n}","map":{"version":3,"sources":["../src/configurations.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  RequestSigner,\n  Credentials,\n  Provider,\n  HashConstructor,\n  RegionInfoProvider,\n  RegionInfo\n} from \"@aws-sdk/types\";\nimport { SignatureV4 } from \"@aws-sdk/signature-v4\";\n\nexport interface AwsAuthInputConfig {\n  /**\n   * The credentials used to sign requests.\n   */\n  credentials?: Credentials | Provider<Credentials>;\n\n  /**\n   * The signer to use when signing requests.\n   */\n  signer?: RequestSigner | Provider<RequestSigner>;\n\n  /**\n   * Whether to escape request path when signing the request.\n   */\n  signingEscapePath?: boolean;\n\n  /**\n   * An offset value in milliseconds to apply to all signing times.\n   */\n  systemClockOffset?: number;\n\n  /**\n   * The region where you want to sign your request against. This\n   * can be different to the region in the endpoint.\n   */\n  signingRegion?: string;\n}\ninterface PreviouslyResolved {\n  credentialDefaultProvider: (input: any) => Provider<Credentials>;\n  region: string | Provider<string>;\n  regionInfoProvider: RegionInfoProvider;\n  signingName: string;\n  sha256: HashConstructor;\n}\nexport interface AwsAuthResolvedConfig {\n  credentials: Provider<Credentials>;\n  signer: Provider<RequestSigner>;\n  signingEscapePath: boolean;\n  systemClockOffset: number;\n}\nexport function resolveAwsAuthConfig<T>(\n  input: T & AwsAuthInputConfig & PreviouslyResolved\n): T & AwsAuthResolvedConfig {\n  let credentials =\n    input.credentials || input.credentialDefaultProvider(input as any);\n  const normalizedCreds = normalizeProvider(credentials);\n  const {\n    signingEscapePath = true,\n    systemClockOffset = input.systemClockOffset || 0,\n    sha256\n  } = input;\n  let signer: Provider<RequestSigner>;\n  if (input.signer) {\n    //if signer is supplied by user, normalize it to a function returning a promise for signer.\n    signer = normalizeProvider(input.signer);\n  } else {\n    //construct a provider inferring signing from region.\n    signer = () =>\n      normalizeProvider(input.region)()\n        .then(\n          async region =>\n            [(await input.regionInfoProvider(region)) || {}, region] as [\n              RegionInfo,\n              string\n            ]\n        )\n        .then(([regionInfo, region]) => {\n          const {\n            signingRegion = input.signingRegion,\n            signingService = input.signingName\n          } = regionInfo;\n          //update client's singing region and signing service config if they are resolved.\n          //signing region resolving order: user supplied signingRegion -> endpoints.json inferred region -> client region\n          input.signingRegion = input.signingRegion || signingRegion || region;\n          input.signingName = input.signingName || signingService;\n\n          return new SignatureV4({\n            credentials: normalizedCreds,\n            region: input.signingRegion,\n            service: input.signingName,\n            sha256,\n            uriEscapePath: signingEscapePath\n          });\n        });\n  }\n\n  return {\n    ...input,\n    systemClockOffset,\n    signingEscapePath,\n    credentials: normalizedCreds,\n    signer\n  };\n}\n\nfunction normalizeProvider<T>(input: T | Provider<T>): Provider<T> {\n  if (typeof input === \"object\") {\n    const promisified = Promise.resolve(input);\n    return () => promisified;\n  }\n  return input as Provider<T>;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}