{"ast":null,"code":"'use strict';\n\nconst util = require('./util');\n\nconst convertToJson = function (node, options, parentTagName) {\n  const jObj = {}; // when no child node or attr is present\n\n  if ((!node.child || util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {\n    return util.isExist(node.val) ? node.val : '';\n  } // otherwise create a textnode if node has some text\n\n\n  if (util.isExist(node.val) && !(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n    const asArray = util.isTagNameInArrayMode(node.tagname, options.arrayMode, parentTagName);\n    jObj[options.textNodeName] = asArray ? [node.val] : node.val;\n  }\n\n  util.merge(jObj, node.attrsMap, options.arrayMode);\n  const keys = Object.keys(node.child);\n\n  for (let index = 0; index < keys.length; index++) {\n    const tagName = keys[index];\n\n    if (node.child[tagName] && node.child[tagName].length > 1) {\n      jObj[tagName] = [];\n\n      for (let tag in node.child[tagName]) {\n        if (node.child[tagName].hasOwnProperty(tag)) {\n          jObj[tagName].push(convertToJson(node.child[tagName][tag], options, tagName));\n        }\n      }\n    } else {\n      const result = convertToJson(node.child[tagName][0], options, tagName);\n      const asArray = options.arrayMode === true && typeof result === 'object' || util.isTagNameInArrayMode(tagName, options.arrayMode, parentTagName);\n      jObj[tagName] = asArray ? [result] : result;\n    }\n  } //add value\n\n\n  return jObj;\n};\n\nexports.convertToJson = convertToJson;","map":{"version":3,"sources":["C:/Users/Kaustubh Sinha/Desktop/bookkart/node_modules/fast-xml-parser/src/node2json.js"],"names":["util","require","convertToJson","node","options","parentTagName","jObj","child","isEmptyObject","attrsMap","isExist","val","cdataPositionChar","asArray","isTagNameInArrayMode","tagname","arrayMode","textNodeName","merge","keys","Object","index","length","tagName","tag","hasOwnProperty","push","result","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst util = require('./util');\n\nconst convertToJson = function(node, options, parentTagName) {\n  const jObj = {};\n\n  // when no child node or attr is present\n  if ((!node.child || util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {\n    return util.isExist(node.val) ? node.val : '';\n  }\n\n  // otherwise create a textnode if node has some text\n  if (util.isExist(node.val) && !(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n    const asArray = util.isTagNameInArrayMode(node.tagname, options.arrayMode, parentTagName)\n    jObj[options.textNodeName] = asArray ? [node.val] : node.val;\n  }\n\n  util.merge(jObj, node.attrsMap, options.arrayMode);\n\n  const keys = Object.keys(node.child);\n  for (let index = 0; index < keys.length; index++) {\n    const tagName = keys[index];\n    if (node.child[tagName] && node.child[tagName].length > 1) {\n      jObj[tagName] = [];\n      for (let tag in node.child[tagName]) {\n        if (node.child[tagName].hasOwnProperty(tag)) {\n          jObj[tagName].push(convertToJson(node.child[tagName][tag], options, tagName));\n        }\n      }\n    } else {\n      const result = convertToJson(node.child[tagName][0], options, tagName);\n      const asArray = (options.arrayMode === true && typeof result === 'object') || util.isTagNameInArrayMode(tagName, options.arrayMode, parentTagName);\n      jObj[tagName] = asArray ? [result] : result;\n    }\n  }\n\n  //add value\n  return jObj;\n};\n\nexports.convertToJson = convertToJson;\n"]},"metadata":{},"sourceType":"script"}