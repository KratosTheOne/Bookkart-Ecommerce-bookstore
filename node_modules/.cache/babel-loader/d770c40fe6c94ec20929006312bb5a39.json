{"ast":null,"code":"var alphabetByEncoding = {};\nvar alphabetByValue = new Array(64);\n\nfor (var i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n  var char = String.fromCharCode(i + start);\n  alphabetByEncoding[char] = i;\n  alphabetByValue[i] = char;\n}\n\nfor (var i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n  var char = String.fromCharCode(i + start);\n  var index = i + 26;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\n\nfor (var i = 0; i < 10; i++) {\n  alphabetByEncoding[i.toString(10)] = i + 52;\n  var char = i.toString(10);\n  var index = i + 52;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\n\nalphabetByEncoding[\"+\"] = 62;\nalphabetByValue[62] = \"+\";\nalphabetByEncoding[\"/\"] = 63;\nalphabetByValue[63] = \"/\";\nvar bitsPerLetter = 6;\nvar bitsPerByte = 8;\nvar maxLetterValue = 63;\n/**\n * Converts a base-64 encoded string to a Uint8Array of bytes.\n *\n * @param input The base-64 encoded string\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\n\nexport function fromBase64(input) {\n  var totalByteLength = input.length / 4 * 3;\n\n  if (input.substr(-2) === \"==\") {\n    totalByteLength -= 2;\n  } else if (input.substr(-1) === \"=\") {\n    totalByteLength--;\n  }\n\n  var out = new ArrayBuffer(totalByteLength);\n  var dataView = new DataView(out);\n\n  for (var i = 0; i < input.length; i += 4) {\n    var bits = 0;\n    var bitLength = 0;\n\n    for (var j = i, limit = i + 3; j <= limit; j++) {\n      if (input[j] !== \"=\") {\n        bits |= alphabetByEncoding[input[j]] << (limit - j) * bitsPerLetter;\n        bitLength += bitsPerLetter;\n      } else {\n        bits >>= bitsPerLetter;\n      }\n    }\n\n    var chunkOffset = i / 4 * 3;\n    bits >>= bitLength % bitsPerByte;\n    var byteLength = Math.floor(bitLength / bitsPerByte);\n\n    for (var k = 0; k < byteLength; k++) {\n      var offset = (byteLength - k - 1) * bitsPerByte;\n      dataView.setUint8(chunkOffset + k, (bits & 255 << offset) >> offset);\n    }\n  }\n\n  return new Uint8Array(out);\n}\n/**\n * Converts a Uint8Array of binary data to a base-64 encoded string.\n *\n * @param input The binary data to encode\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\n\nexport function toBase64(input) {\n  var str = \"\";\n\n  for (var i = 0; i < input.length; i += 3) {\n    var bits = 0;\n    var bitLength = 0;\n\n    for (var j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n      bits |= input[j] << (limit - j - 1) * bitsPerByte;\n      bitLength += bitsPerByte;\n    }\n\n    var bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n    bits <<= bitClusterCount * bitsPerLetter - bitLength;\n\n    for (var k = 1; k <= bitClusterCount; k++) {\n      var offset = (bitClusterCount - k) * bitsPerLetter;\n      str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];\n    }\n\n    str += \"==\".slice(0, 4 - bitClusterCount);\n  }\n\n  return str;\n}","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["const alphabetByEncoding: { [key: string]: number } = {};\nconst alphabetByValue: Array<string> = new Array(64);\n\nfor (let i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  alphabetByEncoding[char] = i;\n  alphabetByValue[i] = char;\n}\n\nfor (let i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  const index = i + 26;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\n\nfor (let i = 0; i < 10; i++) {\n  alphabetByEncoding[i.toString(10)] = i + 52;\n  const char = i.toString(10);\n  const index = i + 52;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\n\nalphabetByEncoding[\"+\"] = 62;\nalphabetByValue[62] = \"+\";\nalphabetByEncoding[\"/\"] = 63;\nalphabetByValue[63] = \"/\";\n\nconst bitsPerLetter = 6;\nconst bitsPerByte = 8;\nconst maxLetterValue = 0b111111;\n\n/**\n * Converts a base-64 encoded string to a Uint8Array of bytes.\n *\n * @param input The base-64 encoded string\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\nexport function fromBase64(input: string): Uint8Array {\n  let totalByteLength = (input.length / 4) * 3;\n  if (input.substr(-2) === \"==\") {\n    totalByteLength -= 2;\n  } else if (input.substr(-1) === \"=\") {\n    totalByteLength--;\n  }\n  const out = new ArrayBuffer(totalByteLength);\n  const dataView = new DataView(out);\n  for (let i = 0; i < input.length; i += 4) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = i + 3; j <= limit; j++) {\n      if (input[j] !== \"=\") {\n        bits |= alphabetByEncoding[input[j]] << ((limit - j) * bitsPerLetter);\n        bitLength += bitsPerLetter;\n      } else {\n        bits >>= bitsPerLetter;\n      }\n    }\n\n    const chunkOffset = (i / 4) * 3;\n    bits >>= bitLength % bitsPerByte;\n    const byteLength = Math.floor(bitLength / bitsPerByte);\n    for (let k = 0; k < byteLength; k++) {\n      const offset = (byteLength - k - 1) * bitsPerByte;\n      dataView.setUint8(chunkOffset + k, (bits & (255 << offset)) >> offset);\n    }\n  }\n\n  return new Uint8Array(out);\n}\n\n/**\n * Converts a Uint8Array of binary data to a base-64 encoded string.\n *\n * @param input The binary data to encode\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\nexport function toBase64(input: Uint8Array): string {\n  let str = \"\";\n  for (let i = 0; i < input.length; i += 3) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n      bits |= input[j] << ((limit - j - 1) * bitsPerByte);\n      bitLength += bitsPerByte;\n    }\n\n    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n    bits <<= bitClusterCount * bitsPerLetter - bitLength;\n    for (let k = 1; k <= bitClusterCount; k++) {\n      const offset = (bitClusterCount - k) * bitsPerLetter;\n      str += alphabetByValue[(bits & (maxLetterValue << offset)) >> offset];\n    }\n\n    str += \"==\".slice(0, 4 - bitClusterCount);\n  }\n\n  return str;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}