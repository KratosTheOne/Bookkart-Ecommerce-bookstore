{"ast":null,"code":"import { KEY_TYPE_IDENTIFIER, MAX_CACHE_SIZE } from \"./constants\";\nvar signingKeyCache = {};\nvar cacheQueue = [];\n/**\n * Create a string describing the scope of credentials used to sign a request.\n *\n * @param shortDate The current calendar date in the form YYYYMMDD.\n * @param region    The AWS region in which the service resides.\n * @param service   The service to which the signed request is being sent.\n */\n\nexport function createScope(shortDate, region, service) {\n  return shortDate + \"/\" + region + \"/\" + service + \"/\" + KEY_TYPE_IDENTIFIER;\n}\n/**\n * Derive a signing key from its composite parts\n *\n * @param sha256Constructor A constructor function that can instantiate SHA-256\n *                          hash objects.\n * @param credentials       The credentials with which the request will be\n *                          signed.\n * @param shortDate         The current calendar date in the form YYYYMMDD.\n * @param region            The AWS region in which the service resides.\n * @param service           The service to which the signed request is being\n *                          sent.\n */\n\nexport function getSigningKey(sha256Constructor, credentials, shortDate, region, service) {\n  var cacheKey = shortDate + \":\" + region + \":\" + service + \":\" + (credentials.accessKeyId + \":\" + credentials.sessionToken);\n\n  if (cacheKey in signingKeyCache) {\n    return signingKeyCache[cacheKey];\n  }\n\n  cacheQueue.push(cacheKey);\n\n  while (cacheQueue.length > MAX_CACHE_SIZE) {\n    delete signingKeyCache[cacheQueue.shift()];\n  }\n\n  return signingKeyCache[cacheKey] = new Promise(function (resolve, reject) {\n    var keyPromise = Promise.resolve(\"AWS4\" + credentials.secretAccessKey);\n\n    var _loop_1 = function (signable) {\n      keyPromise = keyPromise.then(function (intermediateKey) {\n        return hmac(sha256Constructor, intermediateKey, signable);\n      });\n      keyPromise.catch(function () {});\n    };\n\n    for (var _i = 0, _a = [shortDate, region, service, KEY_TYPE_IDENTIFIER]; _i < _a.length; _i++) {\n      var signable = _a[_i];\n\n      _loop_1(signable);\n    }\n\n    keyPromise.then(resolve, function (reason) {\n      delete signingKeyCache[cacheKey];\n      reject(reason);\n    });\n  });\n}\n/**\n * @internal\n */\n\nexport function clearCredentialCache() {\n  cacheQueue.length = 0;\n  Object.keys(signingKeyCache).forEach(function (cacheKey) {\n    delete signingKeyCache[cacheKey];\n  });\n}\n\nfunction hmac(ctor, secret, data) {\n  var hash = new ctor(secret);\n  hash.update(data);\n  return hash.digest();\n}","map":{"version":3,"sources":["../../src/credentialDerivation.ts"],"names":[],"mappings":"AACA,SAAS,mBAAT,EAA8B,cAA9B,QAAoD,aAApD;AAEA,IAAM,eAAe,GAA2C,EAAhE;AACA,IAAM,UAAU,GAAkB,EAAlC;AAEA;;;;;;;;AAOA,OAAM,SAAU,WAAV,CACJ,SADI,EAEJ,MAFI,EAGJ,OAHI,EAGW;AAEf,SAAU,SAAS,GAAA,GAAT,GAAa,MAAb,GAAmB,GAAnB,GAAuB,OAAvB,GAA8B,GAA9B,GAAkC,mBAA5C;AACD;AAED;;;;;;;;;;;;;AAYA,OAAM,SAAU,aAAV,CACJ,iBADI,EAEJ,WAFI,EAGJ,SAHI,EAIJ,MAJI,EAKJ,OALI,EAKW;AAEf,MAAM,QAAQ,GACT,SAAS,GAAA,GAAT,GAAa,MAAb,GAAmB,GAAnB,GAAuB,OAAvB,GAA8B,GAA9B,IACA,WAAW,CAAC,WAAZ,GAAuB,GAAvB,GAA2B,WAAW,CAAC,YADvC,CADL;;AAGA,MAAI,QAAQ,IAAI,eAAhB,EAAiC;AAC/B,WAAO,eAAe,CAAC,QAAD,CAAtB;AACD;;AAED,EAAA,UAAU,CAAC,IAAX,CAAgB,QAAhB;;AACA,SAAO,UAAU,CAAC,MAAX,GAAoB,cAA3B,EAA2C;AACzC,WAAO,eAAe,CAAC,UAAU,CAAC,KAAX,EAAD,CAAtB;AACD;;AAED,SAAQ,eAAe,CAAC,QAAD,CAAf,GAA4B,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;AAC9D,QAAI,UAAU,GAAwB,OAAO,CAAC,OAAR,CACpC,SAAO,WAAW,CAAC,eADiB,CAAtC;;4BAIS,Q,EAAQ;AACf,MAAA,UAAU,GAAG,UAAU,CAAC,IAAX,CAA4B,UAAA,eAAA,EAAe;AACtD,eAAA,IAAI,CAAC,iBAAD,EAAoB,eAApB,EAAqC,QAArC,CAAJ;AAAkD,OADvC,CAAb;AAGA,MAAA,UAAU,CAAC,KAAX,CAAiB,YAAA,CAAQ,CAAzB;;;AAJF,SAAqB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,CAAC,SAAD,EAAY,MAAZ,EAAoB,OAApB,EAA6B,mBAA7B,CAArB,EAAqB,EAAA,GAAA,EAAA,CAAA,MAArB,EAAqB,EAAA,EAArB,EAAsE;AAAjE,UAAI,QAAQ,GAAA,EAAA,CAAA,EAAA,CAAZ;;cAAI,Q;AAKR;;AAEA,IAAA,UAAkC,CAAC,IAAnC,CAAwC,OAAxC,EAAiD,UAAA,MAAA,EAAM;AACtD,aAAO,eAAe,CAAC,QAAD,CAAtB;AACA,MAAA,MAAM,CAAC,MAAD,CAAN;AACD,KAHA;AAIF,GAhBmC,CAApC;AAiBD;AAED;;;;AAGA,OAAM,SAAU,oBAAV,GAA8B;AAClC,EAAA,UAAU,CAAC,MAAX,GAAoB,CAApB;AACA,EAAA,MAAM,CAAC,IAAP,CAAY,eAAZ,EAA6B,OAA7B,CAAqC,UAAA,QAAA,EAAQ;AAC3C,WAAO,eAAe,CAAC,QAAD,CAAtB;AACD,GAFD;AAGD;;AAED,SAAS,IAAT,CACE,IADF,EAEE,MAFF,EAGE,IAHF,EAGkB;AAEhB,MAAM,IAAI,GAAG,IAAI,IAAJ,CAAS,MAAT,CAAb;AACA,EAAA,IAAI,CAAC,MAAL,CAAY,IAAZ;AACA,SAAO,IAAI,CAAC,MAAL,EAAP;AACD","sourceRoot":"","sourcesContent":["import { KEY_TYPE_IDENTIFIER, MAX_CACHE_SIZE } from \"./constants\";\nvar signingKeyCache = {};\nvar cacheQueue = [];\n/**\n * Create a string describing the scope of credentials used to sign a request.\n *\n * @param shortDate The current calendar date in the form YYYYMMDD.\n * @param region    The AWS region in which the service resides.\n * @param service   The service to which the signed request is being sent.\n */\nexport function createScope(shortDate, region, service) {\n    return shortDate + \"/\" + region + \"/\" + service + \"/\" + KEY_TYPE_IDENTIFIER;\n}\n/**\n * Derive a signing key from its composite parts\n *\n * @param sha256Constructor A constructor function that can instantiate SHA-256\n *                          hash objects.\n * @param credentials       The credentials with which the request will be\n *                          signed.\n * @param shortDate         The current calendar date in the form YYYYMMDD.\n * @param region            The AWS region in which the service resides.\n * @param service           The service to which the signed request is being\n *                          sent.\n */\nexport function getSigningKey(sha256Constructor, credentials, shortDate, region, service) {\n    var cacheKey = shortDate + \":\" + region + \":\" + service + \":\" +\n        (credentials.accessKeyId + \":\" + credentials.sessionToken);\n    if (cacheKey in signingKeyCache) {\n        return signingKeyCache[cacheKey];\n    }\n    cacheQueue.push(cacheKey);\n    while (cacheQueue.length > MAX_CACHE_SIZE) {\n        delete signingKeyCache[cacheQueue.shift()];\n    }\n    return (signingKeyCache[cacheKey] = new Promise(function (resolve, reject) {\n        var keyPromise = Promise.resolve(\"AWS4\" + credentials.secretAccessKey);\n        var _loop_1 = function (signable) {\n            keyPromise = keyPromise.then(function (intermediateKey) {\n                return hmac(sha256Constructor, intermediateKey, signable);\n            });\n            keyPromise.catch(function () { });\n        };\n        for (var _i = 0, _a = [shortDate, region, service, KEY_TYPE_IDENTIFIER]; _i < _a.length; _i++) {\n            var signable = _a[_i];\n            _loop_1(signable);\n        }\n        keyPromise.then(resolve, function (reason) {\n            delete signingKeyCache[cacheKey];\n            reject(reason);\n        });\n    }));\n}\n/**\n * @internal\n */\nexport function clearCredentialCache() {\n    cacheQueue.length = 0;\n    Object.keys(signingKeyCache).forEach(function (cacheKey) {\n        delete signingKeyCache[cacheKey];\n    });\n}\nfunction hmac(ctor, secret, data) {\n    var hash = new ctor(secret);\n    hash.update(data);\n    return hash.digest();\n}\n//# sourceMappingURL=credentialDerivation.js.map"]},"metadata":{},"sourceType":"module"}