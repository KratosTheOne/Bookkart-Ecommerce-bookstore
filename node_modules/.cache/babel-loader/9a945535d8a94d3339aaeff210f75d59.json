{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar eventstream_marshaller_1 = require(\"@aws-sdk/eventstream-marshaller\");\n\nvar utils_1 = require(\"./utils\");\n\nvar getChunkedStream_1 = require(\"./getChunkedStream\");\n\nvar getEventMessageStream_1 = require(\"./getEventMessageStream\");\n\nvar getDeserializingStream_1 = require(\"./getDeserializingStream\");\n\nvar EventStreamMarshaller =\n/** @class */\nfunction () {\n  function EventStreamMarshaller(_a) {\n    var utf8Encoder = _a.utf8Encoder,\n        utf8Decoder = _a.utf8Decoder;\n    this.eventMarshaller = new eventstream_marshaller_1.EventStreamMarshaller(utf8Encoder, utf8Decoder);\n  }\n\n  EventStreamMarshaller.prototype.deserialize = function (body, deserializer) {\n    var chunkedStream = getChunkedStream_1.getChunkedStream(body);\n    var messageStream = getEventMessageStream_1.getEventMessageStream(chunkedStream, this.eventMarshaller);\n    var deserialingStream = getDeserializingStream_1.getDeserializingStream(messageStream, deserializer);\n    return utils_1.ReadableStreamtoIterable(deserialingStream);\n  };\n  /**\n   * Generate a ReadableStream that serialize events\n   * to event stream binary chunks; Use a pull stream\n   * here to support low connection speed.\n   *\n   * This doesn't work on browser currently because\n   * browser doesn't support upload streaming.\n   * reference:\n   * * https://bugs.chromium.org/p/chromium/issues/detail?id=688906\n   * * https://bugzilla.mozilla.org/show_bug.cgi?id=1387483\n   *\n   */\n\n\n  EventStreamMarshaller.prototype.serialize = function (input, serializer) {\n    throw new Error(\"event stream request in browser is not supported\\nReference: https://bugs.chromium.org/p/chromium/issues/detail?id=688906\");\n  };\n\n  return EventStreamMarshaller;\n}();\n\nexports.EventStreamMarshaller = EventStreamMarshaller;","map":{"version":3,"sources":["../src/EventStreamMarshaller.ts"],"names":[],"mappings":";;;;;;AAAA,IAAA,wBAAA,GAAA,OAAA,CAAA,iCAAA,CAAA;;AAOA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,IAAA,kBAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AACA,IAAA,uBAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;;AACA,IAAA,wBAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AASA,IAAA,qBAAA;AAAA;AAAA,YAAA;AAEE,WAAA,qBAAA,CAAY,EAAZ,EAAsE;QAAxD,WAAA,GAAA,EAAA,CAAA,W;QAAa,WAAA,GAAA,EAAA,CAAA,W;AACzB,SAAK,eAAL,GAAuB,IAAI,wBAAA,CAAA,qBAAJ,CAAoB,WAApB,EAAiC,WAAjC,CAAvB;AACD;;AAED,EAAA,qBAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UACE,IADF,EAEE,YAFF,EAE0D;AAExD,QAAM,aAAa,GAAG,kBAAA,CAAA,gBAAA,CAAiB,IAAjB,CAAtB;AACA,QAAM,aAAa,GAAG,uBAAA,CAAA,qBAAA,CACpB,aADoB,EAEpB,KAAK,eAFe,CAAtB;AAIA,QAAM,iBAAiB,GAAG,wBAAA,CAAA,sBAAA,CACxB,aADwB,EAExB,YAFwB,CAA1B;AAIA,WAAO,OAAA,CAAA,wBAAA,CAAyB,iBAAzB,CAAP;AACD,GAdD;AAgBA;;;;;;;;;;;;;;AAYA,EAAA,qBAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UACE,KADF,EAEE,UAFF,EAEmC;AAEjC,UAAM,IAAI,KAAJ,CAAU,2HAAV,CAAN;AAED,GAND;;AAOF,SAAA,qBAAA;AAAC,CAzCD,EAAA;;AAAa,OAAA,CAAA,qBAAA,GAAA,qBAAA","sourcesContent":["import { EventStreamMarshaller as EventMarshaller } from \"@aws-sdk/eventstream-marshaller\";\nimport {\n  Encoder,\n  Decoder,\n  Message,\n  EventStreamMarshaller as IEventStreamMarshaller\n} from \"@aws-sdk/types\";\nimport { ReadableStreamtoIterable } from \"./utils\";\nimport { getChunkedStream } from \"./getChunkedStream\";\nimport { getEventMessageStream } from \"./getEventMessageStream\";\nimport { getDeserializingStream } from \"./getDeserializingStream\";\n\nexport interface EventStreamMarshaller extends IEventStreamMarshaller {}\n\nexport interface EventStreamMarshallerOptions {\n  utf8Encoder: Encoder;\n  utf8Decoder: Decoder;\n}\n\nexport class EventStreamMarshaller {\n  private readonly eventMarshaller: EventMarshaller;\n  constructor({ utf8Encoder, utf8Decoder }: EventStreamMarshallerOptions) {\n    this.eventMarshaller = new EventMarshaller(utf8Encoder, utf8Decoder);\n  }\n\n  deserialize<T>(\n    body: ReadableStream,\n    deserializer: (input: { [event: string]: Message }) => T\n  ): AsyncIterable<T> {\n    const chunkedStream = getChunkedStream(body);\n    const messageStream = getEventMessageStream(\n      chunkedStream,\n      this.eventMarshaller\n    );\n    const deserialingStream = getDeserializingStream(\n      messageStream,\n      deserializer\n    );\n    return ReadableStreamtoIterable(deserialingStream);\n  }\n\n  /**\n   * Generate a ReadableStream that serialize events\n   * to event stream binary chunks; Use a pull stream\n   * here to support low connection speed.\n   *\n   * This doesn't work on browser currently because\n   * browser doesn't support upload streaming.\n   * reference:\n   * * https://bugs.chromium.org/p/chromium/issues/detail?id=688906\n   * * https://bugzilla.mozilla.org/show_bug.cgi?id=1387483\n   *\n   */\n  serialize<T>(\n    input: AsyncIterable<T>,\n    serializer: (event: T) => Message\n  ): ReadableStream {\n    throw new Error(`event stream request in browser is not supported\nReference: https://bugs.chromium.org/p/chromium/issues/detail?id=688906`);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}