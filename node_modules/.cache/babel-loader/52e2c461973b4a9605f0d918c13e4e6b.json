{"ast":null,"code":"export function attachEventProps(node, newProps, oldProps) {\n  if (oldProps === void 0) {\n    oldProps = {};\n  }\n\n  var className = getClassName(node.classList, newProps, oldProps);\n\n  if (className) {\n    node.className = className;\n  }\n\n  Object.keys(newProps).forEach(function (name) {\n    if (name === 'children' || name === 'style' || name === 'ref' || name === 'className') {\n      return;\n    }\n\n    if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n      var eventName = name.substring(2);\n      var eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);\n\n      if (!isCoveredByReact(eventNameLc)) {\n        syncEvent(node, eventNameLc, newProps[name]);\n      }\n    } else {\n      node[name] = newProps[name];\n    }\n  });\n}\nexport function getClassName(classList, newProps, oldProps) {\n  // map the classes to Maps for performance\n  var currentClasses = arrayToMap(classList);\n  var incomingPropClasses = arrayToMap(newProps.className ? newProps.className.split(' ') : []);\n  var oldPropClasses = arrayToMap(oldProps.className ? oldProps.className.split(' ') : []);\n  var finalClassNames = []; // loop through each of the current classes on the component\n  // to see if it should be a part of the classNames added\n\n  currentClasses.forEach(function (currentClass) {\n    if (incomingPropClasses.has(currentClass)) {\n      // add it as its already included in classnames coming in from newProps\n      finalClassNames.push(currentClass);\n      incomingPropClasses.delete(currentClass);\n    } else if (!oldPropClasses.has(currentClass)) {\n      // add it as it has NOT been removed by user\n      finalClassNames.push(currentClass);\n    }\n  });\n  incomingPropClasses.forEach(function (s) {\n    return finalClassNames.push(s);\n  });\n  return finalClassNames.join(' ');\n}\n/**\n * Checks if an event is supported in the current execution environment.\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\n\nexport function isCoveredByReact(eventNameSuffix, doc) {\n  if (doc === void 0) {\n    doc = document;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = (eventName in doc);\n\n  if (!isSupported) {\n    var element = doc.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  return isSupported;\n}\nexport function syncEvent(node, eventName, newEventHandler) {\n  var eventStore = node.__events || (node.__events = {});\n  var oldEventHandler = eventStore[eventName]; // Remove old listener so they don't double up.\n\n  if (oldEventHandler) {\n    node.removeEventListener(eventName, oldEventHandler);\n  }\n\n  if (newEventHandler != null) {\n    // Bind new listener.\n    node.addEventListener(eventName, eventStore[eventName] = function handler(e) {\n      newEventHandler.call(this, e);\n    });\n  }\n}\n\nfunction arrayToMap(arr) {\n  var map = new Map();\n  arr.forEach(function (s) {\n    return map.set(s, s);\n  });\n  return map;\n}","map":{"version":3,"sources":["../../../src/react-component-lib/utils/attachEventProps.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["export function attachEventProps(node, newProps, oldProps) {\n    if (oldProps === void 0) { oldProps = {}; }\n    var className = getClassName(node.classList, newProps, oldProps);\n    if (className) {\n        node.className = className;\n    }\n    Object.keys(newProps).forEach(function (name) {\n        if (name === 'children' || name === 'style' || name === 'ref' || name === 'className') {\n            return;\n        }\n        if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n            var eventName = name.substring(2);\n            var eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);\n            if (!isCoveredByReact(eventNameLc)) {\n                syncEvent(node, eventNameLc, newProps[name]);\n            }\n        }\n        else {\n            node[name] = newProps[name];\n        }\n    });\n}\nexport function getClassName(classList, newProps, oldProps) {\n    // map the classes to Maps for performance\n    var currentClasses = arrayToMap(classList);\n    var incomingPropClasses = arrayToMap(newProps.className ? newProps.className.split(' ') : []);\n    var oldPropClasses = arrayToMap(oldProps.className ? oldProps.className.split(' ') : []);\n    var finalClassNames = [];\n    // loop through each of the current classes on the component\n    // to see if it should be a part of the classNames added\n    currentClasses.forEach(function (currentClass) {\n        if (incomingPropClasses.has(currentClass)) {\n            // add it as its already included in classnames coming in from newProps\n            finalClassNames.push(currentClass);\n            incomingPropClasses.delete(currentClass);\n        }\n        else if (!oldPropClasses.has(currentClass)) {\n            // add it as it has NOT been removed by user\n            finalClassNames.push(currentClass);\n        }\n    });\n    incomingPropClasses.forEach(function (s) { return finalClassNames.push(s); });\n    return finalClassNames.join(' ');\n}\n/**\n * Checks if an event is supported in the current execution environment.\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nexport function isCoveredByReact(eventNameSuffix, doc) {\n    if (doc === void 0) { doc = document; }\n    var eventName = 'on' + eventNameSuffix;\n    var isSupported = eventName in doc;\n    if (!isSupported) {\n        var element = doc.createElement('div');\n        element.setAttribute(eventName, 'return;');\n        isSupported = typeof element[eventName] === 'function';\n    }\n    return isSupported;\n}\nexport function syncEvent(node, eventName, newEventHandler) {\n    var eventStore = node.__events || (node.__events = {});\n    var oldEventHandler = eventStore[eventName];\n    // Remove old listener so they don't double up.\n    if (oldEventHandler) {\n        node.removeEventListener(eventName, oldEventHandler);\n    }\n    if (newEventHandler != null) {\n        // Bind new listener.\n        node.addEventListener(eventName, (eventStore[eventName] = function handler(e) {\n            newEventHandler.call(this, e);\n        }));\n    }\n}\nfunction arrayToMap(arr) {\n    var map = new Map();\n    arr.forEach(function (s) { return map.set(s, s); });\n    return map;\n}\n//# sourceMappingURL=attachEventProps.js.map"]},"metadata":{},"sourceType":"module"}