{"ast":null,"code":"const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods; // This is a function to prevent it throwing up in node environments.\n\nfunction getIdbProxyableTypes() {\n  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n} // This is a function to prevent it throwing up in node environments.\n\n\nfunction getCursorAdvanceMethods() {\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);\n}\n\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\n\nfunction promisifyRequest(request) {\n  const promise = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      request.removeEventListener('success', success);\n      request.removeEventListener('error', error);\n    };\n\n    const success = () => {\n      resolve(wrap(request.result));\n      unlisten();\n    };\n\n    const error = () => {\n      reject(request.error);\n      unlisten();\n    };\n\n    request.addEventListener('success', success);\n    request.addEventListener('error', error);\n  });\n  promise.then(value => {\n    // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n    // (see wrapFunction).\n    if (value instanceof IDBCursor) {\n      cursorRequestMap.set(value, request);\n    } // Catching to avoid \"Uncaught Promise exceptions\"\n\n  }).catch(() => {}); // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n  // is because we create many promises from a single IDBRequest.\n\n  reverseTransformCache.set(promise, request);\n  return promise;\n}\n\nfunction cacheDonePromiseForTransaction(tx) {\n  // Early bail if we've already created a done promise for this transaction.\n  if (transactionDoneMap.has(tx)) return;\n  const done = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      tx.removeEventListener('complete', complete);\n      tx.removeEventListener('error', error);\n      tx.removeEventListener('abort', error);\n    };\n\n    const complete = () => {\n      resolve();\n      unlisten();\n    };\n\n    const error = () => {\n      reject(tx.error || new DOMException('AbortError', 'AbortError'));\n      unlisten();\n    };\n\n    tx.addEventListener('complete', complete);\n    tx.addEventListener('error', error);\n    tx.addEventListener('abort', error);\n  }); // Cache it for later retrieval.\n\n  transactionDoneMap.set(tx, done);\n}\n\nlet idbProxyTraps = {\n  get(target, prop, receiver) {\n    if (target instanceof IDBTransaction) {\n      // Special handling for transaction.done.\n      if (prop === 'done') return transactionDoneMap.get(target); // Polyfill for objectStoreNames because of Edge.\n\n      if (prop === 'objectStoreNames') {\n        return target.objectStoreNames || transactionStoreNamesMap.get(target);\n      } // Make tx.store return the only store in the transaction, or undefined if there are many.\n\n\n      if (prop === 'store') {\n        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n      }\n    } // Else transform whatever we get back.\n\n\n    return wrap(target[prop]);\n  },\n\n  set(target, prop, value) {\n    target[prop] = value;\n    return true;\n  },\n\n  has(target, prop) {\n    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n      return true;\n    }\n\n    return prop in target;\n  }\n\n};\n\nfunction replaceTraps(callback) {\n  idbProxyTraps = callback(idbProxyTraps);\n}\n\nfunction wrapFunction(func) {\n  // Due to expected object equality (which is enforced by the caching in `wrap`), we\n  // only create one new func per func.\n  // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n  if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {\n    return function (storeNames, ...args) {\n      const tx = func.call(unwrap(this), storeNames, ...args);\n      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n      return wrap(tx);\n    };\n  } // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n  // with real promises, so each advance methods returns a new promise for the cursor object, or\n  // undefined if the end of the cursor has been reached.\n\n\n  if (getCursorAdvanceMethods().includes(func)) {\n    return function (...args) {\n      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n      // the original object.\n      func.apply(unwrap(this), args);\n      return wrap(cursorRequestMap.get(this));\n    };\n  }\n\n  return function (...args) {\n    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n    // the original object.\n    return wrap(func.apply(unwrap(this), args));\n  };\n}\n\nfunction transformCachableValue(value) {\n  if (typeof value === 'function') return wrapFunction(value); // This doesn't return, it just creates a 'done' promise for the transaction,\n  // which is later returned for transaction.done (see idbObjectHandler).\n\n  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps); // Return the same value back if we're not going to transform it.\n\n  return value;\n}\n\nfunction wrap(value) {\n  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n  if (value instanceof IDBRequest) return promisifyRequest(value); // If we've already transformed this value before, reuse the transformed value.\n  // This is faster, but it also provides object equality.\n\n  if (transformCache.has(value)) return transformCache.get(value);\n  const newValue = transformCachableValue(value); // Not all types are transformed.\n  // These may be primitive types, so they can't be WeakMap keys.\n\n  if (newValue !== value) {\n    transformCache.set(value, newValue);\n    reverseTransformCache.set(newValue, value);\n  }\n\n  return newValue;\n}\n\nconst unwrap = value => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };","map":{"version":3,"sources":["C:/Users/Kaustubh Sinha/Desktop/bookkart/node_modules/idb/build/esm/wrap-idb-value.js"],"names":["instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","IDBDatabase","IDBObjectStore","IDBIndex","IDBCursor","IDBTransaction","getCursorAdvanceMethods","prototype","advance","continue","continuePrimaryKey","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","promisifyRequest","request","promise","Promise","resolve","reject","unlisten","removeEventListener","success","error","wrap","result","addEventListener","then","value","set","catch","cacheDonePromiseForTransaction","tx","has","done","complete","DOMException","idbProxyTraps","get","target","prop","receiver","objectStoreNames","undefined","objectStore","replaceTraps","callback","wrapFunction","func","transaction","storeNames","args","call","unwrap","sort","includes","apply","transformCachableValue","Proxy","IDBRequest","newValue","a","i","r","u","w"],"mappings":"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","sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n"]},"metadata":{},"sourceType":"module"}