{"ast":null,"code":"import { isArrayBuffer } from \"@aws-sdk/is-array-buffer\";\nimport { Buffer } from \"buffer\";\nexport var fromArrayBuffer = function (input, offset, length) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  if (length === void 0) {\n    length = input.byteLength - offset;\n  }\n\n  if (!isArrayBuffer(input)) {\n    throw new TypeError(\"The \\\"input\\\" argument must be ArrayBuffer. Received type \" + typeof input + \" (\" + input + \")\");\n  }\n\n  return Buffer.from(input, offset, length);\n};\nexport var fromString = function (input, encoding) {\n  if (typeof input !== \"string\") {\n    throw new TypeError(\"The \\\"input\\\" argument must be of type string. Received type \" + typeof input + \" (\" + input + \")\");\n  }\n\n  return encoding ? Buffer.from(input, encoding) : Buffer.from(input);\n};","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,SAAS,aAAT,QAA8B,0BAA9B;AACA,SAAS,MAAT,QAAuB,QAAvB;AAEA,OAAO,IAAM,eAAe,GAAG,UAAC,KAAD,EAAqB,MAArB,EAAiC,MAAjC,EAA2E;AAAtD,MAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,MAAA,GAAA,CAAA;AAAU;;AAAE,MAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,MAAA,GAAiB,KAAK,CAAC,UAAN,GAAmB,MAApC;AAA0C;;AACxG,MAAI,CAAC,aAAa,CAAC,KAAD,CAAlB,EAA2B;AACzB,UAAM,IAAI,SAAJ,CAAc,+DAA2D,OAAO,KAAlE,GAAuE,IAAvE,GAA4E,KAA5E,GAAiF,GAA/F,CAAN;AACD;;AAED,SAAO,MAAM,CAAC,IAAP,CAAY,KAAZ,EAAmB,MAAnB,EAA2B,MAA3B,CAAP;AACD,CANM;AAUP,OAAO,IAAM,UAAU,GAAG,UAAC,KAAD,EAAgB,QAAhB,EAAyC;AACjE,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAM,IAAI,SAAJ,CAAc,kEAA8D,OAAO,KAArE,GAA0E,IAA1E,GAA+E,KAA/E,GAAoF,GAAlG,CAAN;AACD;;AAED,SAAO,QAAQ,GAAG,MAAM,CAAC,IAAP,CAAY,KAAZ,EAAmB,QAAnB,CAAH,GAAkC,MAAM,CAAC,IAAP,CAAY,KAAZ,CAAjD;AACD,CANM","sourcesContent":["import { isArrayBuffer } from \"@aws-sdk/is-array-buffer\";\nimport { Buffer } from \"buffer\";\n\nexport const fromArrayBuffer = (input: ArrayBuffer, offset = 0, length: number = input.byteLength - offset): Buffer => {\n  if (!isArrayBuffer(input)) {\n    throw new TypeError(`The \"input\" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);\n  }\n\n  return Buffer.from(input, offset, length);\n};\n\nexport type StringEncoding = \"ascii\" | \"utf8\" | \"utf16le\" | \"ucs2\" | \"base64\" | \"latin1\" | \"binary\" | \"hex\";\n\nexport const fromString = (input: string, encoding?: StringEncoding): Buffer => {\n  if (typeof input !== \"string\") {\n    throw new TypeError(`The \"input\" argument must be of type string. Received type ${typeof input} (${input})`);\n  }\n\n  return encoding ? Buffer.from(input, encoding) : Buffer.from(input);\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}