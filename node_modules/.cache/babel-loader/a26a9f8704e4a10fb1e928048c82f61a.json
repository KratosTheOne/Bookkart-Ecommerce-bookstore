{"ast":null,"code":"import { __values } from \"tslib\";\nimport { KEY_TYPE_IDENTIFIER, MAX_CACHE_SIZE } from \"./constants\";\nvar signingKeyCache = {};\nvar cacheQueue = [];\n/**\n * Create a string describing the scope of credentials used to sign a request.\n *\n * @param shortDate The current calendar date in the form YYYYMMDD.\n * @param region    The AWS region in which the service resides.\n * @param service   The service to which the signed request is being sent.\n */\n\nexport function createScope(shortDate, region, service) {\n  return shortDate + \"/\" + region + \"/\" + service + \"/\" + KEY_TYPE_IDENTIFIER;\n}\n/**\n * Derive a signing key from its composite parts\n *\n * @param sha256Constructor A constructor function that can instantiate SHA-256\n *                          hash objects.\n * @param credentials       The credentials with which the request will be\n *                          signed.\n * @param shortDate         The current calendar date in the form YYYYMMDD.\n * @param region            The AWS region in which the service resides.\n * @param service           The service to which the signed request is being\n *                          sent.\n */\n\nexport function getSigningKey(sha256Constructor, credentials, shortDate, region, service) {\n  var cacheKey = shortDate + \":\" + region + \":\" + service + \":\" + (credentials.accessKeyId + \":\" + credentials.sessionToken);\n\n  if (cacheKey in signingKeyCache) {\n    return signingKeyCache[cacheKey];\n  }\n\n  cacheQueue.push(cacheKey);\n\n  while (cacheQueue.length > MAX_CACHE_SIZE) {\n    delete signingKeyCache[cacheQueue.shift()];\n  }\n\n  return signingKeyCache[cacheKey] = new Promise(function (resolve, reject) {\n    var e_1, _a;\n\n    var keyPromise = Promise.resolve(\"AWS4\" + credentials.secretAccessKey);\n\n    var _loop_1 = function (signable) {\n      keyPromise = keyPromise.then(function (intermediateKey) {\n        return hmac(sha256Constructor, intermediateKey, signable);\n      });\n      keyPromise.catch(function () {});\n    };\n\n    try {\n      for (var _b = __values([shortDate, region, service, KEY_TYPE_IDENTIFIER]), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var signable = _c.value;\n\n        _loop_1(signable);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    keyPromise.then(resolve, function (reason) {\n      delete signingKeyCache[cacheKey];\n      reject(reason);\n    });\n  });\n}\n/**\n * @internal\n */\n\nexport function clearCredentialCache() {\n  cacheQueue.length = 0;\n  Object.keys(signingKeyCache).forEach(function (cacheKey) {\n    delete signingKeyCache[cacheKey];\n  });\n}\n\nfunction hmac(ctor, secret, data) {\n  var hash = new ctor(secret);\n  hash.update(data);\n  return hash.digest();\n}","map":{"version":3,"sources":["../../src/credentialDerivation.ts"],"names":[],"mappings":";AAEA,SAAS,mBAAT,EAA8B,cAA9B,QAAoD,aAApD;AAEA,IAAM,eAAe,GAA2C,EAAhE;AACA,IAAM,UAAU,GAAkB,EAAlC;AAEA;;;;;;AAMG;;AACH,OAAM,SAAU,WAAV,CAAsB,SAAtB,EAAyC,MAAzC,EAAyD,OAAzD,EAAwE;AAC5E,SAAU,SAAS,GAAA,GAAT,GAAa,MAAb,GAAmB,GAAnB,GAAuB,OAAvB,GAA8B,GAA9B,GAAkC,mBAA5C;AACD;AAED;;;;;;;;;;;AAWG;;AACH,OAAM,SAAU,aAAV,CACJ,iBADI,EAEJ,WAFI,EAGJ,SAHI,EAIJ,MAJI,EAKJ,OALI,EAKW;AAEf,MAAM,QAAQ,GAAM,SAAS,GAAA,GAAT,GAAa,MAAb,GAAmB,GAAnB,GAAuB,OAAvB,GAA8B,GAA9B,IAAuC,WAAW,CAAC,WAAZ,GAAuB,GAAvB,GAA2B,WAAW,CAAC,YAA9E,CAApB;;AACA,MAAI,QAAQ,IAAI,eAAhB,EAAiC;AAC/B,WAAO,eAAe,CAAC,QAAD,CAAtB;AACD;;AAED,EAAA,UAAU,CAAC,IAAX,CAAgB,QAAhB;;AACA,SAAO,UAAU,CAAC,MAAX,GAAoB,cAA3B,EAA2C;AACzC,WAAO,eAAe,CAAC,UAAU,CAAC,KAAX,EAAD,CAAtB;AACD;;AAED,SAAQ,eAAe,CAAC,QAAD,CAAf,GAA4B,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;;;AAC9D,QAAI,UAAU,GAAwB,OAAO,CAAC,OAAR,CAAgB,SAAO,WAAW,CAAC,eAAnC,CAAtC;;4BAEW,Q,EAAQ;AACjB,MAAA,UAAU,GAAG,UAAU,CAAC,IAAX,CAA4B,UAAC,eAAD,EAAgB;AAAK,eAAA,IAAI,CAAC,iBAAD,EAAoB,eAApB,EAAJ,QAAI,CAAJ;AAAkD,OAAnG,CAAb;AACA,MAAA,UAAU,CAAC,KAAX,CAAiB,YAAA,CAAQ,CAAzB;;;;AAFF,WAAuB,IAAA,EAAA,GAAA,QAAA,CAAA,CAAC,SAAD,EAAY,MAAZ,EAAoB,OAApB,EAA6B,mBAA7B,CAAA,CAAA,EAAiD,EAAA,GAAA,EAAA,CAAA,IAAA,EAAxE,EAAwE,CAAA,EAAA,CAAA,IAAxE,EAAwE,EAAA,GAAA,EAAA,CAAA,IAAA,EAAxE,EAAwE;AAAnE,YAAM,QAAQ,GAAA,EAAA,CAAA,KAAd;;gBAAM,Q;AAGV;;;;;;;;;;;;;AAEA,IAAA,UAAkC,CAAC,IAAnC,CAAwC,OAAxC,EAAiD,UAAC,MAAD,EAAO;AACvD,aAAO,eAAe,CAAC,QAAD,CAAtB;AACA,MAAA,MAAM,CAAC,MAAD,CAAN;AACD,KAHA;AAIF,GAZmC,CAApC;AAaD;AAED;;AAEG;;AACH,OAAM,SAAU,oBAAV,GAA8B;AAClC,EAAA,UAAU,CAAC,MAAX,GAAoB,CAApB;AACA,EAAA,MAAM,CAAC,IAAP,CAAY,eAAZ,EAA6B,OAA7B,CAAqC,UAAC,QAAD,EAAS;AAC5C,WAAO,eAAe,CAAC,QAAD,CAAtB;AACD,GAFD;AAGD;;AAED,SAAS,IAAT,CAAc,IAAd,EAAqC,MAArC,EAAyD,IAAzD,EAAyE;AACvE,MAAM,IAAI,GAAG,IAAI,IAAJ,CAAS,MAAT,CAAb;AACA,EAAA,IAAI,CAAC,MAAL,CAAY,IAAZ;AACA,SAAO,IAAI,CAAC,MAAL,EAAP;AACD","sourcesContent":["import { Credentials, HashConstructor, SourceData } from \"@aws-sdk/types\";\n\nimport { KEY_TYPE_IDENTIFIER, MAX_CACHE_SIZE } from \"./constants\";\n\nconst signingKeyCache: { [key: string]: Promise<Uint8Array> } = {};\nconst cacheQueue: Array<string> = [];\n\n/**\n * Create a string describing the scope of credentials used to sign a request.\n *\n * @param shortDate The current calendar date in the form YYYYMMDD.\n * @param region    The AWS region in which the service resides.\n * @param service   The service to which the signed request is being sent.\n */\nexport function createScope(shortDate: string, region: string, service: string): string {\n  return `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;\n}\n\n/**\n * Derive a signing key from its composite parts\n *\n * @param sha256Constructor A constructor function that can instantiate SHA-256\n *                          hash objects.\n * @param credentials       The credentials with which the request will be\n *                          signed.\n * @param shortDate         The current calendar date in the form YYYYMMDD.\n * @param region            The AWS region in which the service resides.\n * @param service           The service to which the signed request is being\n *                          sent.\n */\nexport function getSigningKey(\n  sha256Constructor: HashConstructor,\n  credentials: Credentials,\n  shortDate: string,\n  region: string,\n  service: string\n): Promise<Uint8Array> {\n  const cacheKey = `${shortDate}:${region}:${service}:` + `${credentials.accessKeyId}:${credentials.sessionToken}`;\n  if (cacheKey in signingKeyCache) {\n    return signingKeyCache[cacheKey];\n  }\n\n  cacheQueue.push(cacheKey);\n  while (cacheQueue.length > MAX_CACHE_SIZE) {\n    delete signingKeyCache[cacheQueue.shift() as string];\n  }\n\n  return (signingKeyCache[cacheKey] = new Promise((resolve, reject) => {\n    let keyPromise: Promise<SourceData> = Promise.resolve(`AWS4${credentials.secretAccessKey}`);\n\n    for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {\n      keyPromise = keyPromise.then<Uint8Array>((intermediateKey) => hmac(sha256Constructor, intermediateKey, signable));\n      keyPromise.catch(() => {});\n    }\n\n    (keyPromise as Promise<Uint8Array>).then(resolve, (reason) => {\n      delete signingKeyCache[cacheKey];\n      reject(reason);\n    });\n  }));\n}\n\n/**\n * @internal\n */\nexport function clearCredentialCache(): void {\n  cacheQueue.length = 0;\n  Object.keys(signingKeyCache).forEach((cacheKey) => {\n    delete signingKeyCache[cacheKey];\n  });\n}\n\nfunction hmac(ctor: HashConstructor, secret: SourceData, data: SourceData): Promise<Uint8Array> {\n  const hash = new ctor(secret);\n  hash.update(data);\n  return hash.digest();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}