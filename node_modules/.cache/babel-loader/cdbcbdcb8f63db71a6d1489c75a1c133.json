{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { runPolling } from \"./poller\";\nimport { validateWaiterOptions } from \"./utils\";\nimport { waiterServiceDefaults, WaiterState } from \"./waiter\";\n\nvar abortTimeout = function (abortSignal) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      return [2\n      /*return*/\n      , new Promise(function (resolve) {\n        abortSignal.onabort = function () {\n          return resolve({\n            state: WaiterState.ABORTED\n          });\n        };\n      })];\n    });\n  });\n};\n/**\n * Create a waiter promise that only resolves when:\n * 1. Abort controller is signaled\n * 2. Max wait time is reached\n * 3. `acceptorChecks` succeeds, or fails\n * Otherwise, it invokes `acceptorChecks` with exponential-backoff delay.\n *\n * @internal\n */\n\n\nexport var createWaiter = function (options, input, acceptorChecks) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var params, exitConditions;\n    return __generator(this, function (_a) {\n      params = __assign(__assign({}, waiterServiceDefaults), options);\n      validateWaiterOptions(params);\n      exitConditions = [runPolling(params, input, acceptorChecks)];\n\n      if (options.abortController) {\n        exitConditions.push(abortTimeout(options.abortController.signal));\n      }\n\n      return [2\n      /*return*/\n      , Promise.race(exitConditions)];\n    });\n  });\n};","map":{"version":3,"sources":["../../src/createWaiter.ts"],"names":[],"mappings":";AAEA,SAAS,UAAT,QAA2B,UAA3B;AACA,SAAS,qBAAT,QAAsC,SAAtC;AACA,SAAsC,qBAAtC,EAA6D,WAA7D,QAAgF,UAAhF;;AAEA,IAAM,YAAY,GAAG,UAAO,WAAP,EAA+B;AAAA,SAAA,SAAA,CAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,YAAA;;AAClD,aAAA,CAAA;AAAA;AAAA,QAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAQ;AACzB,QAAA,WAAW,CAAC,OAAZ,GAAsB,YAAA;AAAM,iBAAA,OAAO,CAAC;AAAE,YAAA,KAAK,EAAE,WAAW,CAA5B;AAAQ,WAAD,CAAP;AAAuC,SAAnE;AACD,OAFM,CAAP,CAAA;;GADkD,CAAA;AAInD,CAJD;AAMA;;;;;;;;AAQG;;;AACH,OAAO,IAAM,YAAY,GAAG,UAC1B,OAD0B,EAE1B,KAF0B,EAG1B,cAH0B,EAG6C;AAAA,SAAA,SAAA,CAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,YAAA;;;AAEjE,MAAA,MAAM,GAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACP,qBADO,CAAA,EAEP,OAFO,CAAN;AAIN,MAAA,qBAAqB,CAAC,MAAD,CAArB;AAEM,MAAA,cAAc,GAAG,CAAC,UAAU,CAAgB,MAAhB,EAAwB,KAAxB,EAA+B,cAA/B,CAAX,CAAjB;;AACN,UAAI,OAAO,CAAC,eAAZ,EAA6B;AAC3B,QAAA,cAAc,CAAC,IAAf,CAAoB,YAAY,CAAC,OAAO,CAAC,eAAR,CAAwB,MAAzB,CAAhC;AACD;;AACD,aAAA,CAAA;AAAA;AAAA,QAAO,OAAO,CAAC,IAAR,CAAa,cAAb,CAAP,CAAA;;GAZuE,CAAA;AAaxE,CAhBM","sourcesContent":["import { AbortSignal } from \"@aws-sdk/types\";\n\nimport { runPolling } from \"./poller\";\nimport { validateWaiterOptions } from \"./utils\";\nimport { WaiterOptions, WaiterResult, waiterServiceDefaults, WaiterState } from \"./waiter\";\n\nconst abortTimeout = async (abortSignal: AbortSignal): Promise<WaiterResult> => {\n  return new Promise((resolve) => {\n    abortSignal.onabort = () => resolve({ state: WaiterState.ABORTED });\n  });\n};\n\n/**\n * Create a waiter promise that only resolves when:\n * 1. Abort controller is signaled\n * 2. Max wait time is reached\n * 3. `acceptorChecks` succeeds, or fails\n * Otherwise, it invokes `acceptorChecks` with exponential-backoff delay.\n *\n * @internal\n */\nexport const createWaiter = async <Client, Input>(\n  options: WaiterOptions<Client>,\n  input: Input,\n  acceptorChecks: (client: Client, input: Input) => Promise<WaiterResult>\n): Promise<WaiterResult> => {\n  const params = {\n    ...waiterServiceDefaults,\n    ...options,\n  };\n  validateWaiterOptions(params);\n\n  const exitConditions = [runPolling<Client, Input>(params, input, acceptorChecks)];\n  if (options.abortController) {\n    exitConditions.push(abortTimeout(options.abortController.signal));\n  }\n  return Promise.race(exitConditions);\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}